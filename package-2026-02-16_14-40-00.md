## ./test/test_helpers.go
```
// test/test_helpers.go
package test

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// SetupTestRepository creates a temporary Git repository for testing
func SetupTestRepository(t *testing.T) string {
	t.Helper()

	tmpDir, err := os.MkdirTemp("", "prbuddy-test-")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}

	// Initialize Git repository
	if err := os.Chdir(tmpDir); err != nil {
		t.Fatalf("Failed to change to temp directory: %v", err)
	}

	if _, err := utils.ExecGit("init"); err != nil {
		t.Fatalf("Failed to init Git repo: %v", err)
	}

	// Create test files with realistic content
	files := map[string]string{
		"cmd/context.go": `package cmd

import (
	"fmt"
)

func init() {
	fmt.Println("Initializing command package")
}

func ExampleFunction() {
	// Example implementation
}
`,
		"internal/contextpkg/context.go": `package contextpkg

type Message struct {
	Role    string ` + "`" + `json:"role"` + "`" + `
	Content string ` + "`" + `json:"content"` + "`" + `
}

type Task struct {
	Description string   ` + "`" + `json:"description"` + "`" + `
	Files       []string ` + "`" + `json:"files"` + "`" + `
	Functions   []string ` + "`" + `json:"functions"` + "`" + `
}
`,
		"internal/dce/dce.go": `package dce

type DCE interface {
	Activate(task string) error
	Deactivate(conversationID string) error
	BuildTaskList(input string) ([]contextpkg.Task, []string, error)
}

type DefaultDCE struct{}

func NewDCE() DCE {
	return &DefaultDCE{}
}
`,
		"internal/dce/command_menu.go": `package dce

func HandleDCECommandMenu(input string, littleguy *LittleGuy) bool {
	// Command handling logic
	return true
}
`,
		"README.md": "# Test Repository\nThis is a test repository for PRBuddy-Go",
	}

	for path, content := range files {
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			t.Fatalf("Failed to create directory: %v", err)
		}
		if err := os.WriteFile(path, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to write file: %v", err)
		}
	}

	// Add and commit files
	if _, err := utils.ExecGit("add", "."); err != nil {
		t.Fatalf("Failed to add files: %v", err)
	}
	if _, err := utils.ExecGit("commit", "-m", "Initial commit"); err != nil {
		t.Fatalf("Failed to commit: %v", err)
	}

	return tmpDir
}

// CleanupTestRepository removes the temporary repository
func CleanupTestRepository(t *testing.T, repoPath string) {
	t.Helper()
	if err := os.RemoveAll(repoPath); err != nil {
		t.Logf("Failed to cleanup test repository: %v", err)
	}
}

// SetupDCEForTesting initializes a DCE instance for testing
// SetupDCEForTesting initializes a DCE instance for testing
func SetupDCEForTesting(t *testing.T, initialTask string) (string, *dce.LittleGuy) {
	t.Helper()

	// Initialize DCE
	dceInstance := dce.NewDCE()
	if err := dceInstance.Activate(initialTask); err != nil {
		t.Fatalf("Failed to activate DCE: %v", err)
	}

	// Get the conversation ID from the DCE context
	var conversationID string
	var littleguy *dce.LittleGuy

	// Use ForEachContext to find the first context
	found := false
	dce.GetDCEContextManager().ForEachContext(func(cid string, ctx *dce.LittleGuy) {
		conversationID = cid
		littleguy = ctx
		found = true
	})

	if !found {
		t.Fatal("Failed to get LittleGuy instance after DCE activation")
	}

	return conversationID, littleguy
}

// AssertTaskContains checks if a task contains specific elements
func AssertTaskContains(t *testing.T, task contextpkg.Task, description string, files []string, functions []string) {
	t.Helper()

	if task.Description != description {
		t.Errorf("Expected task description '%s', got '%s'", description, task.Description)
	}

	// Check files
	if len(files) != len(task.Files) {
		t.Errorf("Expected %d files, got %d", len(files), len(task.Files))
	} else {
		for i, file := range files {
			if task.Files[i] != file {
				t.Errorf("Expected file '%s' at index %d, got '%s'", file, i, task.Files[i])
			}
		}
	}

	// Check functions
	if len(functions) != len(task.Functions) {
		t.Errorf("Expected %d functions, got %d", len(functions), len(task.Functions))
	} else {
		for i, fn := range functions {
			if task.Functions[i] != fn {
				t.Errorf("Expected function '%s' at index %d, got '%s'", fn, i, task.Functions[i])
			}
		}
	}
}
```
## ./test/dce/command_menu/help_test.go
```
// test/dce/command_menu/help_test.go
package command_menu_test

import (
	"bytes"
	"fmt"
	"strings"
	"testing"

	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/test"
)

func TestHelpCommandDisplaysCorrectly(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Test task")

	// Capture output
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)

	// Test /help
	dce.HandleDCECommandMenu("/help", littleguy)
	output := mockOutput.String()

	// Verify command menu is displayed
	if !strings.Contains(output, "Available DCE Commands") {
		t.Error("Help output doesn't contain command menu header")
	}

	// Verify /add is in the command list
	if !strings.Contains(output, "/add <description>") {
		t.Error("Help output doesn't include /add command")
	}

	// Verify all command aliases are mentioned
	if !strings.Contains(output, "/commands, /cmds, /help") {
		t.Error("Help output doesn't properly list all command aliases")
	}
}

func TestAllHelpCommandAliasesWork(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Test task")

	// Test all help command variants
	commands := []string{"/help", "/commands", "/cmds"}

	for _, cmd := range commands {
		t.Run(fmt.Sprintf("Command_%s", cmd), func(t *testing.T) {
			mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
			SetOutputForTests(mockOutput)

			dce.HandleDCECommandMenu(cmd, littleguy)
			output := mockOutput.String()

			if !strings.Contains(output, "Available DCE Commands") {
				t.Errorf("Output for '%s' doesn't contain command menu", cmd)
			}

			if !strings.Contains(output, "/add <description>") {
				t.Errorf("Output for '%s' doesn't include /add command", cmd)
			}
		})
	}
}
```
## ./test/dce/command_menu/integration_test.go
```
// test/dce/command_menu/integration_test.go
package command_menu_test

import (
	"bytes"
	"strings"
	"testing"

	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/test"
)

func TestIntegration_FullDCEWorkflow(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Step 1: Add a task
	dce.HandleDCECommandMenu("/add Implement test helpers", littleguy)

	// Step 2: Check tasks
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/tasks", littleguy)
	output := mockOutput.String()

	if !strings.Contains(output, "Implement test helpers") {
		t.Error("Added task not found in task list")
	}

	// Step 3: Check status
	mockOutput = &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/status", littleguy)
	output = mockOutput.String()

	if !strings.Contains(output, "Active Tasks:") {
		t.Error("Status output missing")
	}

	// Step 4: Mark task as completed
	dce.HandleDCECommandMenu("/complete 1", littleguy)

	// Step 5: Verify task was removed
	mockOutput = &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/tasks", littleguy)
	output = mockOutput.String()

	if strings.Contains(output, "Implement test helpers") {
		t.Error("Completed task still appears in task list")
	}
}

func TestIntegration_DCEActivationDeactivation(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Test DCE activation
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/dce on", littleguy)
	output := mockOutput.String()

	if !strings.Contains(output, "Dynamic Context Engine activated") {
		t.Error("DCE activation message not found")
	}

	// Check status after activation
	mockOutput = &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/status", littleguy)
	output = mockOutput.String()

	if !strings.Contains(output, "ACTIVE") {
		t.Error("DCE should show as ACTIVE")
	}

	// Test DCE deactivation
	mockOutput = &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/dce off", littleguy)
	output = mockOutput.String()

	if !strings.Contains(output, "Dynamic Context Engine deactivated") {
		t.Error("DCE deactivation message not found")
	}
}

func TestIntegration_TaskPrioritization(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Add multiple tasks
	dce.HandleDCECommandMenu("/add Task 1: Critical bug fix", littleguy)
	dce.HandleDCECommandMenu("/add Task 2: Feature implementation", littleguy)
	dce.HandleDCECommandMenu("/add Task 3: Documentation update", littleguy)

	// Set priorities
	dce.HandleDCECommandMenu("/priority 1 high", littleguy)
	dce.HandleDCECommandMenu("/priority 2 medium", littleguy)
	dce.HandleDCECommandMenu("/priority 3 low", littleguy)

	// Check priorities
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/priority", littleguy)
	output := mockOutput.String()

	// Verify priority labels are present
	expectedPriorities := []string{"[High]", "[Medium]", "[Low]"}
	for _, priority := range expectedPriorities {
		if !strings.Contains(output, priority) {
			t.Errorf("Expected priority '%s' not found in output", priority)
		}
	}
}

func TestIntegration_CommandAliases(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Test different command aliases
	testCases := []struct {
		command     string
		shouldMatch bool
	}{
		{"/task", true},
		{"/tasks", true},
		{"/cmds", true},
		{"/commands", true},
		{"/help", true},
		{"/invalid", false},
	}

	for _, tc := range testCases {
		t.Run("Command_"+tc.command, func(t *testing.T) {
			mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
			SetOutputForTests(mockOutput)

			result := dce.HandleDCECommandMenu(tc.command, littleguy)

			if tc.shouldMatch && !result {
				t.Errorf("Command '%s' should have been handled but wasn't", tc.command)
			}
			if !tc.shouldMatch && result {
				t.Errorf("Command '%s' should not have been handled but was", tc.command)
			}
		})
	}
}

func TestIntegration_RefreshTaskList(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Add a task
	dce.HandleDCECommandMenu("/add Implement test helpers", littleguy)

	// Manually trigger refresh
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/refresh", littleguy)
	output := mockOutput.String()

	if !strings.Contains(output, "Refreshing task list from git changes") {
		t.Error("Refresh command output not as expected")
	}
}

func TestIntegration_InvalidCommands(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	invalidCommands := []string{
		"/add",               // missing description
		"/priority",          // missing args
		"/complete",          // missing task number
		"/complete abc",      // invalid task number
		"/priority abc high", // invalid task number
		"/dce unknown",       // invalid dce subcommand
	}

	for _, cmd := range invalidCommands {
		t.Run("Invalid_"+cmd, func(t *testing.T) {
			mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
			SetOutputForTests(mockOutput)

			dce.HandleDCECommandMenu(cmd, littleguy)
			output := mockOutput.String()

			// Should see some error message (not empty)
			if output == "" {
				t.Errorf("Expected error output for invalid command '%s', got empty", cmd)
			}
		})
	}
}
```
## ./test/dce/command_menu/testutils_test.go
```
// test/dce/command_menu/testutils_test.go
package command_menu_test

import (
	"bytes"
	"io"

	"github.com/soyuz43/prbuddy-go/internal/dce"
)

// MockOutputWriter captures output for testing
type MockOutputWriter struct {
	*bytes.Buffer
}

func (m *MockOutputWriter) Write(p []byte) (n int, err error) {
	return m.Buffer.Write(p)
}

// SetOutputForTests allows redirecting output for tests
func SetOutputForTests(w io.Writer) {
	dce.SetOutput(w)
}
```
## ./test/dce/command_menu/add_test.go
```
// test/dce/command_menu/add_test.go
package command_menu_test

import (
	"bytes"
	"strings"
	"testing"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/test"
)

func TestAddCommand_AddsNewTask(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Add a new task with description that will match test files
	dce.HandleDCECommandMenu("/add Implement test helpers", littleguy)

	// Capture verbose output to see files and functions
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/tasks -v", littleguy)

	// Verify the new task appears in the verbose task list
	output := mockOutput.String()
	if !strings.Contains(output, "Implement test helpers") {
		t.Error("Added task not found in task list")
	}

	// Verify task details are displayed in verbose mode
	if !strings.Contains(output, "add_test.go") {
		t.Error("Expected file 'add_test.go' not found in verbose task list")
	}
	if !strings.Contains(output, "help_test.go") {
		t.Error("Expected file 'help_test.go' not found in verbose task list")
	}

	// Verify function presence in verbose mode
	if !strings.Contains(output, "TestAddCommand_AddsNewTask") {
		t.Error("Expected function 'TestAddCommand_AddsNewTask' not found in verbose task list")
	}
	if !strings.Contains(output, "TestHelpCommandDisplaysCorrectly") {
		t.Error("Expected function 'TestHelpCommandDisplaysCorrectly' not found in verbose task list")
	}
}

func TestAddCommand_WithVerboseOutput(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Add a new task with description that will match test files
	dce.HandleDCECommandMenu("/add Implement test helpers", littleguy)

	// Capture verbose task output
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/tasks -v", littleguy)

	// Verify verbose details are displayed
	output := mockOutput.String()
	if !strings.Contains(output, "Implement test helpers") {
		t.Error("Added task not found in verbose task list")
	}

	// Verify all details are displayed in verbose mode
	if !strings.Contains(output, "add_test.go") {
		t.Error("Expected file 'add_test.go' not found in verbose task list")
	}
	if !strings.Contains(output, "TestAddCommand_AddsNewTask") {
		t.Error("Expected function 'TestAddCommand_AddsNewTask' not found in verbose task list")
	}
	if !strings.Contains(output, "Matched via input and file heuristics.") {
		t.Error("Expected notes not displayed in verbose task list")
	}
}

func TestAddCommand_WithEmptyDescription(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Capture output
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)

	// Try to add a task with empty description
	dce.HandleDCECommandMenu("/add", littleguy)

	// Verify error message
	output := mockOutput.String()
	if !strings.Contains(output, "Please provide a task description") {
		t.Errorf("Expected error message about empty description, got: %q", output)
	}
}

func TestAddCommand_WhenDCEInactive(t *testing.T) {
	// Setup - create DCE but don't activate it
	conversationID := contextpkg.GenerateConversationID("test")
	littleguy := dce.NewLittleGuy(conversationID, []contextpkg.Task{})

	// Capture output
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)

	// Try to add a task with DCE inactive
	dce.HandleDCECommandMenu("/add Test task", littleguy)

	// Verify output
	output := mockOutput.String()
	if !strings.Contains(output, "Successfully added 1 task(s) to the task list") {
		t.Errorf("Expected success message, got: %q", output)
	}

	// Verify task was added
	mockOutput = &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/tasks", littleguy)
	output = mockOutput.String()

	if !strings.Contains(output, "Test task") {
		t.Error("Added task not found in task list")
	}
}

func TestAddCommand_MultipleTasks(t *testing.T) {
	// Setup
	_, littleguy := test.SetupDCEForTesting(t, "Initial task")

	// Add multiple tasks
	tasks := []string{
		"/add Implement core functionality",
		"/add Add error handling",
		"/add Write documentation",
	}

	for _, task := range tasks {
		dce.HandleDCECommandMenu(task, littleguy)
	}

	// Capture output
	mockOutput := &MockOutputWriter{Buffer: &bytes.Buffer{}}
	SetOutputForTests(mockOutput)
	dce.HandleDCECommandMenu("/tasks", littleguy)

	output := mockOutput.String()

	// Verify all tasks are present
	for _, task := range tasks {
		description := strings.TrimPrefix(task, "/add ")
		if !strings.Contains(output, description) {
			t.Errorf("Task '%s' not found in task list", description)
		}
	}
}
```
## ./test/dce/task_helper/build_task_list_test.go
```
// test/dce/task_helper/build_task_list_test.go
package task_helper

import (
	"strings"
	"testing"

	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/test"
)

func TestBuildTaskListWithMatchingFiles(t *testing.T) {
	// Setup test repository
	repoPath := test.SetupTestRepository(t)
	defer test.CleanupTestRepository(t, repoPath)

	// Build task list for a description that should match files
	tasks, logs, err := dce.BuildTaskList("context package")
	if err != nil {
		t.Fatalf("BuildTaskList failed: %v", err)
	}

	// Verify logs - update to expect 2 files
	foundFilesLog := false
	for _, log := range logs {
		if strings.Contains(log, "Matched 2 files: [cmd/context.go internal/contextpkg/context.go]") {
			foundFilesLog = true
			break
		}
	}
	if !foundFilesLog {
		t.Error("Expected log about matched files not found")
	}

	// Verify tasks
	if len(tasks) != 1 {
		t.Fatalf("Expected 1 task, got %d", len(tasks))
	}

	task := tasks[0]
	if task.Description != "context package" {
		t.Errorf("Expected task description 'context package', got '%s'", task.Description)
	}

	// Check files - verify both expected files are present
	expectedFiles := []string{"cmd/context.go", "internal/contextpkg/context.go"}
	if len(task.Files) != len(expectedFiles) {
		t.Errorf("Expected %d files, got %d", len(expectedFiles), len(task.Files))
	}

	for _, expectedFile := range expectedFiles {
		found := false
		for _, file := range task.Files {
			if file == expectedFile {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected file '%s' not found in task.Files", expectedFile)
		}
	}

	if len(task.Functions) == 0 {
		t.Error("Expected at least one function to be extracted")
	}
}

func TestBuildTaskListWithNoMatchingFiles(t *testing.T) {
	// Setup test repository
	repoPath := test.SetupTestRepository(t)
	defer test.CleanupTestRepository(t, repoPath)

	// Build task list for a description that shouldn't match files
	tasks, logs, err := dce.BuildTaskList("nonexistent feature")
	if err != nil {
		t.Fatalf("BuildTaskList failed: %v", err)
	}

	// Verify logs
	foundCatchAllLog := false
	for _, log := range logs {
		if strings.Contains(log, "No file matches found - created catch-all task") {
			foundCatchAllLog = true
			break
		}
	}
	if !foundCatchAllLog {
		t.Error("Expected log about catch-all task not found")
	}

	// Verify tasks
	if len(tasks) != 1 {
		t.Fatalf("Expected 1 task, got %d", len(tasks))
	}

	task := tasks[0]
	if task.Description != "nonexistent feature" {
		t.Errorf("Expected task description 'nonexistent feature', got '%s'", task.Description)
	}

	if len(task.Files) != 0 {
		t.Errorf("Expected no files, got %v", task.Files)
	}

	if len(task.Notes) == 0 || !strings.Contains(task.Notes[0], "No direct file matches found") {
		t.Error("Expected 'no file matches' note not found in task")
	}
}

func TestBuildTaskListWithFunctionExtraction(t *testing.T) {
	// Setup test repository
	repoPath := test.SetupTestRepository(t)
	defer test.CleanupTestRepository(t, repoPath)

	// Build task list for a description that should match a file with functions
	tasks, _, err := dce.BuildTaskList("cmd context")
	if err != nil {
		t.Fatalf("BuildTaskList failed: %v", err)
	}

	if len(tasks) != 1 {
		t.Fatalf("Expected 1 task, got %d", len(tasks))
	}

	task := tasks[0]
	if len(task.Functions) == 0 {
		t.Error("Expected at least one function to be extracted")
	} else {
		// Verify init function was extracted
		foundInit := false
		for _, fn := range task.Functions {
			if fn == "init" {
				foundInit = true
				break
			}
		}
		if !foundInit {
			t.Error("Expected 'init' function to be extracted, but it wasn't found")
		}

		// Verify ExampleFunction was extracted
		foundExample := false
		for _, fn := range task.Functions {
			if fn == "ExampleFunction" {
				foundExample = true
				break
			}
		}
		if !foundExample {
			t.Error("Expected 'ExampleFunction' to be extracted, but it wasn't found")
		}
	}
}
```
## ./cmd/post_commit.go
```
// cmd/post_commit.go

package cmd

import (
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/llm"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

var (
	extensionActive   bool
	nonInteractive    bool
	extensionAttempts = 3
	extensionDelay    = 500 * time.Millisecond
)

// ConversationLog represents the structure for logging conversations
type ConversationLog struct {
	BranchName string               `json:"branch_name"`
	CommitHash string               `json:"commit_hash"`
	Messages   []contextpkg.Message `json:"messages"`
}

var postCommitCmd = &cobra.Command{
	Use:   "post-commit",
	Short: "Handle post-commit automation",
	Long:  `Generates PR drafts and coordinates with VS Code extension when available`,
	Run:   runPostCommit,
}

func init() {
	postCommitCmd.Flags().BoolVar(&extensionActive, "extension-active", false,
		"Indicates extension connectivity check")
	postCommitCmd.Flags().BoolVar(&nonInteractive, "non-interactive", false,
		"Disable interactive prompts")
	rootCmd.AddCommand(postCommitCmd)
}

func runPostCommit(cmd *cobra.Command, args []string) {
	if !nonInteractive {
		fmt.Println("[PRBuddy-Go] Starting post-commit workflow...")
	}

	branchName, commitHash, draftPR, err := generateDraftPR()
	if err != nil {
		handleGenerationError(err)
		return
	}

	if extensionActive {
		if commErr := communicateWithExtension(branchName, commitHash, draftPR); commErr != nil {
			handleExtensionFailure(draftPR, commErr)
		}
	} else {
		presentTerminalOutput(draftPR)
	}

	if logErr := saveConversationLogs(branchName, commitHash, "Draft generated"); logErr != nil {
		fmt.Printf("[PRBuddy-Go] Logging error: %v\n", logErr)
	}

	if !nonInteractive {
		fmt.Println("[PRBuddy-Go] Post-commit workflow completed")
	}
}

func generateDraftPR() (string, string, string, error) {
	branchName, err := utils.ExecGit("rev-parse", "--abbrev-ref", "HEAD")
	if err != nil {
		return "", "", "", fmt.Errorf("branch detection failed: %w", err)
	}

	commitHash, err := utils.ExecGit("rev-parse", "HEAD")
	if err != nil {
		return "", "", "", fmt.Errorf("commit hash retrieval failed: %w", err)
	}

	commitMessage, diffs, err := llm.GeneratePreDraftPR()
	if err != nil {
		return "", "", "", fmt.Errorf("pre-draft generation failed: %w", err)
	}

	if diffs == "" {
		return "", "", "", fmt.Errorf("no detectable changes")
	}

	draftPR, err := llm.GenerateDraftPR(commitMessage, diffs)
	if err != nil {
		return "", "", "", fmt.Errorf("draft generation failed: %w", err)
	}

	return strings.TrimSpace(branchName), strings.TrimSpace(commitHash), draftPR, nil
}

func communicateWithExtension(branch, hash, draft string) error {
	if err := activateExtension(); err != nil {
		return fmt.Errorf("extension activation: %w", err)
	}

	port, err := utils.ReadPortFile()
	if err != nil {
		return fmt.Errorf("port retrieval: %w", err)
	}

	return retryCommunication(port, branch, hash, draft)
}

func activateExtension() error {
	cmd := exec.Command("code", "--activate-extension", "prbuddy.extension")
	return cmd.Run()
}

func retryCommunication(port int, branch, hash, draft string) error {
	client := http.Client{Timeout: 2 * time.Second}
	payload := map[string]interface{}{
		"branch":    branch,
		"commit":    hash,
		"draft_pr":  draft,
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}

	jsonPayload, err := utils.MarshalJSON(payload)
	if err != nil {
		return fmt.Errorf("failed to marshal payload: %w", err)
	}

	for i := 0; i < extensionAttempts; i++ {
		resp, err := client.Post(
			fmt.Sprintf("http://localhost:%d/extension", port),
			"application/json",
			strings.NewReader(string(jsonPayload)),
		)

		if err == nil && resp.StatusCode == http.StatusOK {
			return nil
		}

		time.Sleep(extensionDelay)
	}

	return fmt.Errorf("failed after %d attempts", extensionAttempts)
}

func handleExtensionFailure(draft string, err error) {
	fmt.Printf("\n[PRBuddy-Go] Extension communication failed: %v\n", err)
	presentTerminalOutput(draft)
}

func presentTerminalOutput(draft string) {
	const line = "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
	fmt.Printf("\n%s\nðŸš€ Draft PR Generated\n%s\n%s\n%s\n\n",
		line, line, draft, line)
}

func saveConversationLogs(branch, hash, message string) error {
	repoPath, err := utils.GetRepoPath()
	if err != nil {
		return fmt.Errorf("repo path detection: %w", err)
	}

	logDir := filepath.Join(repoPath, ".git", "pr_buddy_db",
		sanitizeBranchName(branch), fmt.Sprintf("commit-%s", hash[:7]))

	if err := os.MkdirAll(logDir, 0755); err != nil {
		return fmt.Errorf("log directory creation: %w", err)
	}

	conversation := ConversationLog{
		BranchName: branch,
		CommitHash: hash,
		Messages: []contextpkg.Message{
			{Role: "system", Content: "Initiated draft generation"},
			{Role: "assistant", Content: message},
		},
	}

	conversationJSON, err := utils.MarshalJSON(conversation)
	if err != nil {
		return err
	}

	if err := saveFile(logDir, "conversation.json", string(conversationJSON)); err != nil {
		return err
	}

	draftContext := []contextpkg.Message{
		{Role: "system", Content: "Initial draft context"},
		{Role: "assistant", Content: message},
	}

	draftContextJSON, err := utils.MarshalJSON(draftContext)
	if err != nil {
		return err
	}

	return saveFile(logDir, "draft_context.json", string(draftContextJSON))
}

func saveFile(dir, filename, content string) error {
	path := filepath.Join(dir, filename)
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("file write failed: %w", err)
	}

	return nil
}

func sanitizeBranchName(branch string) string {
	return strings.ReplaceAll(strings.ReplaceAll(branch, "/", "_"), " ", "-")
}

func handleGenerationError(err error) {
	fmt.Printf("[PRBuddy-Go] Critical error: %v\n", err)
	fmt.Println("Failed to generate draft PR. Check git status and try again.")
}
```
## ./cmd/remove.go
```
// cmd/remove.go

package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/soyuz43/prbuddy-go/internal/hooks"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

// removeCmd represents the remove command
var removeCmd = &cobra.Command{
	Use:   "remove",
	Short: "Remove PRBuddy-Go from the repository.",
	Long:  `Deletes Git hooks and cleans up other traces of PRBuddy-Go from the repository.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("[PRBuddy-Go] Running remove command...")

		// 1. Remove the post-commit hook
		err := hooks.RemovePostCommitHook()
		if err != nil {
			fmt.Printf("[PRBuddy-Go] Error removing post-commit hook: %v\n", err)
		} else {
			fmt.Println("[PRBuddy-Go] Removed the post-commit hook.")
		}

		// 2. Remove the .git/pr_buddy_db directory
		repoPath, err := utils.GetRepoPath()
		if err != nil {
			fmt.Printf("[PRBuddy-Go] Error retrieving repository path: %v\n", err)
			return
		}

		prBuddyDBPath := filepath.Join(repoPath, ".git", "pr_buddy_db")
		if _, err := os.Stat(prBuddyDBPath); !os.IsNotExist(err) {
			err = os.RemoveAll(prBuddyDBPath)
			if err != nil {
				fmt.Printf("[PRBuddy-Go] Error deleting pr_buddy_db directory: %v\n", err)
			} else {
				fmt.Printf("[PRBuddy-Go] Deleted directory: %s\n", prBuddyDBPath)
			}
		} else {
			fmt.Printf("[PRBuddy-Go] Directory does not exist: %s\n", prBuddyDBPath)
		}

		fmt.Println("[PRBuddy-Go] Successfully removed all traces of PRBuddy-Go from the repository.")
	},
}

func init() {
	rootCmd.AddCommand(removeCmd)
}
```
## ./cmd/init.go
```
package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/soyuz43/prbuddy-go/internal/hooks"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize PRBuddy-Go in the current Git repository.",
	Long: `Installs a post-commit hook (optionally) and creates the .git/pr_buddy_db directory.
If you choose not to install the post-commit hook now, you can install it later manually.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("[PRBuddy-Go] Initializing PRBuddy-Go...")

		// 1. Prompt the user about installing the post-commit hook
		reader := bufio.NewReader(os.Stdin)
		fmt.Print("[PRBuddy-Go] Generate pr automatically on commit?  [y/N] ")

		userInput, err := reader.ReadString('\n')
		if err != nil {
			fmt.Printf("[PRBuddy-Go] Error reading input: %v\n", err)
			// Fall back to skipping the hook if there's an I/O error
			userInput = "n"
		}
		userInput = strings.TrimSpace(strings.ToLower(userInput))

		if userInput == "y" || userInput == "yes" {
			// Attempt to install the post-commit hook
			if err := hooks.InstallPostCommitHook(); err != nil {
				fmt.Printf("[PRBuddy-Go] Error installing post-commit hook: %v\n", err)
			} else {
				fmt.Println("[PRBuddy-Go] Post-commit hook installation complete.")
			}
		} else {
			fmt.Println("[PRBuddy-Go] Skipping post-commit hook installation.")
		}

		// 2. Create .git/pr_buddy_db directory
		repoPath, err := utils.GetRepoPath()
		if err != nil {
			fmt.Printf("[PRBuddy-Go] Error retrieving repository path: %v\n", err)
			return
		}

		prBuddyDBPath := filepath.Join(repoPath, ".git", "pr_buddy_db")
		err = os.MkdirAll(prBuddyDBPath, 0750)
		if err != nil {
			fmt.Printf("[PRBuddy-Go] Error creating pr_buddy_db directory: %v\n", err)
			return
		}

		fmt.Printf("[PRBuddy-Go] Created directory: %s\n", prBuddyDBPath)
		fmt.Println("[PRBuddy-Go] Initialization complete.")
	},
}

func init() {
	rootCmd.AddCommand(initCmd)
}
```
## ./cmd/map.go
```
// cmd/map.go

package cmd

import (
	"fmt"
	"strings"

	"github.com/soyuz43/prbuddy-go/internal/treesitter"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

var mapCmd = &cobra.Command{
	Use:   "map",
	Short: "Generate project scaffolds using tree-sitter parsing",
	Long:  "Scans the repository using the Go parser, builds project metadata and a project map, and saves the results to scaffold files.",
	Run: func(cmd *cobra.Command, args []string) {
		// 1. Get repository root directory
		repoPath, err := utils.GetRepoPath()
		if err != nil {
			fmt.Printf("Error retrieving repository path: %v\n", err)
			return
		}

		// 2. Retrieve the current branch name
		branchName, err := utils.ExecGit("rev-parse", "--abbrev-ref", "HEAD")
		if err != nil {
			fmt.Printf("Error retrieving branch name: %v\n", err)
			return
		}
		branchName = strings.TrimSpace(branchName)

		// 3. Create a new Go parser (for now, we only support Go)
		parser := treesitter.NewGoParser()

		// 4. Build the project metadata
		metadata, err := parser.BuildProjectMetadata(repoPath)
		if err != nil {
			fmt.Printf("Error building project metadata: %v\n", err)
			return
		}

		// 5. Build the project map (function dependency map)
		projectMap, err := parser.BuildProjectMap(repoPath)
		if err != nil {
			fmt.Printf("Error building project map: %v\n", err)
			return
		}

		// 6. Save the metadata and project map using the saver functions
		if err := treesitter.SaveMetadata(metadata, branchName); err != nil {
			fmt.Printf("Error saving project metadata: %v\n", err)
			return
		}
		if err := treesitter.SaveProjectMap(projectMap, branchName); err != nil {
			fmt.Printf("Error saving project map: %v\n", err)
			return
		}

		fmt.Println("Project scaffolds generated successfully.")
	},
}

func init() {
	rootCmd.AddCommand(mapCmd)
}
```
## ./cmd/common.go
```
package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/fatih/color"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

// Color definitions

var (
	cyan  = utils.Cyan
	green = utils.Green
	//lint:ignore U1000 This variable is intentionally unused.
	yellow = utils.Yellow
	//lint:ignore U1000 This variable is intentionally unused.
	red = utils.Red
	//lint:ignore U1000 This variable is intentionally unused.
	magenta = utils.Magenta
	bold    = utils.Bold
)

// Root command
var rootCmd = &cobra.Command{
	Use:   "prbuddy-go",
	Short: "PRBuddy-Go: Enhance your pull request workflow.",
	Long:  `PRBuddy-Go helps automate pull request generation, manage Git hooks, and provide insightful feedback predictions.`,
	Run:   runRootCommand,
}

// Execute executes the root command.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		color.Red("Error executing command: %v\n", err)
		os.Exit(1)
	}
}

// isInitialized checks if PRBuddy is initialized in the current repository
func isInitialized() (bool, error) {
	repoPath, err := utils.GetRepoPath()
	if err != nil {
		return false, fmt.Errorf("failed to get repository path: %w", err)
	}

	// Check for the existence of the pr_buddy_db directory
	prBuddyDBPath := filepath.Join(repoPath, ".git", "pr_buddy_db")
	if _, err := os.Stat(prBuddyDBPath); err != nil {
		if os.IsNotExist(err) {
			return false, nil // Not initialized
		}
		return false, fmt.Errorf("error checking pr_buddy_db: %w", err)
	}

	return true, nil // Initialized
}
```
## ./cmd/quick_assist.go
```
// cmd/quick_assist.go

package cmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/soyuz43/prbuddy-go/internal/llm"
	"github.com/spf13/cobra"
)

var quickAssistCmd = &cobra.Command{
	Use:     "quickassist [query]",
	Aliases: []string{"qa"},
	Short:   "Get quick assistance from the LLM (interactive mode if no query provided)",
	Args:    cobra.ArbitraryArgs, // Allows zero or more arguments
	Run: func(cmd *cobra.Command, args []string) {
		// If user provides arguments, treat it as a one-time query
		if len(args) > 0 {
			query := strings.Join(args, " ")
			handleSingleQuickAssist(query)
			return
		}

		// Otherwise, start interactive chat session
		StartInteractiveQuickAssist()
	},
}

func handleSingleQuickAssist(query string) {
	if strings.TrimSpace(query) == "" {
		color.Red("Error: No question provided.\n")
		return
	}

	// Use a new conversation (empty ConversationID to generate a new one)
	response, err := llm.HandleQuickAssist("", query)
	if err != nil {
		color.Red("Error: %v\n", err)
		return
	}

	// Display assistant response
	fmt.Println("\nQuickAssist Response:")
	color.Cyan(response)
}

// StartInteractiveQuickAssist starts the interactive chat session.
// Exported so it can be called from root.go
func StartInteractiveQuickAssist() {
	color.Cyan("\n[PRBuddy-Go] Quick Assist - Interactive Mode")
	color.Yellow("Type 'exit' or 'q' to end the session.\n")

	reader := bufio.NewReader(os.Stdin)
	conversationID := "" // Start a new conversation

	for {
		// Prompt for user input
		color.Green("You:")
		fmt.Print("> ")
		input, err := reader.ReadString('\n')
		if err != nil {
			color.Red("Error reading input: %v\n", err)
			continue
		}

		// Trim spaces and check for exit condition
		query := strings.TrimSpace(input)
		if strings.EqualFold(query, "exit") || strings.EqualFold(query, "q") {
			color.Cyan("\n[PRBuddy-Go] Ending Quick Assist session.\n")
			break
		}

		if query == "" {
			color.Yellow("Please enter a valid question or type 'exit' to quit.")
			continue
		}

		// Get response from Quick Assist
		response, err := llm.HandleQuickAssist(conversationID, query)
		if err != nil {
			color.Red("Error: %v\n", err)
			continue
		}

		// Display assistant response
		color.Blue("Assistant:")
		color.Cyan(response)
	}
}

func init() {
	rootCmd.AddCommand(quickAssistCmd)
	// Removed unnecessary flags
}
```
## ./cmd/context.go
```
// cmd/context.go
package cmd

import (
	"fmt"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/llm"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

var contextCmd = &cobra.Command{
	Use:   "context",
	Short: "Manage PRBuddy-Go conversation context",
}

var saveCmd = &cobra.Command{
	Use:   "save",
	Short: "Save current conversation context to disk",
	Run: func(cmd *cobra.Command, args []string) {
		branch, _ := utils.GetCurrentBranch()
		commit, _ := utils.GetLatestCommit()
		conv, exists := contextpkg.ConversationManagerInstance.GetConversation("current")
		if !exists {
			fmt.Println("No active conversation to save.")
			return
		}
		err := llm.SaveDraftContext(branch, commit, conv.BuildContext())
		if err != nil {
			fmt.Println("Error saving context:", err)
		} else {
			fmt.Printf("âœ… Context saved for %s@%s\n", branch, commit[:7])
		}
	},
}

var loadCmd = &cobra.Command{
	Use:   "load [branch] [commit]",
	Short: "Load a saved context into memory",
	Args:  cobra.ExactArgs(2),
	Run: func(cmd *cobra.Command, args []string) {
		branch := args[0]
		commit := args[1]
		ctx, err := llm.LoadDraftContext(branch, commit)
		if err != nil {
			fmt.Println("âŒ Failed to load context:", err)
			return
		}
		conv := contextpkg.ConversationManagerInstance.StartConversation("current", "", false)
		conv.SetMessages(ctx)
		fmt.Printf("âœ… Loaded context for %s@%s into memory\n", branch, commit[:7])
	},
}

func init() {
	rootCmd.AddCommand(contextCmd)
	contextCmd.AddCommand(saveCmd)
	contextCmd.AddCommand(loadCmd)
}
```
## ./cmd/what.go
```
// cmd/what.go

package cmd

import (
	"fmt"

	"github.com/soyuz43/prbuddy-go/internal/llm"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

var whatCmd = &cobra.Command{
	Use:   "what",
	Short: "Summarize recent changes since the last commit.",
	Long: `Analyzes staged, unstaged, and untracked changes in the repository 
and provides a natural language summary using the LLM.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("[PRBuddy-Go] Running 'what' command...")

		// Get the dce flag value
		useDCE, _ := cmd.Flags().GetBool("dce")

		// Check if there are any commits in the repository
		commitCount, err := utils.ExecGit("rev-list", "--count", "HEAD")
		if err != nil {
			fmt.Printf("[PRBuddy-Go] Error checking commits: %v\n", err)
			return
		}
		if commitCount == "0" {
			fmt.Println("[PRBuddy-Go] No commits found in the repository. Please make a commit first.")
			return
		}

		// Generate and display the summary
		var summary string

		if useDCE {
			fmt.Println("[PRBuddy-Go] Using Dynamic Context Engine for enhanced context awareness")
			summary, err = llm.GenerateWhatSummaryWithDCEContext()
		} else {
			summary, err = llm.GenerateWhatSummary()
		}

		if err != nil {
			if err.Error() == "no changes detected since the last commit" {
				fmt.Println("[PRBuddy-Go] No changes detected.")
				return
			}
			fmt.Printf("[PRBuddy-Go] Error generating summary: %v\n", err)
			return
		}

		fmt.Println("\n**What Have I Done Since the Last Commit:**")
		fmt.Println(summary)
	},
}

func init() {
	// Add DCE flag to enable context-aware summaries
	whatCmd.Flags().Bool("dce", false, "Use Dynamic Context Engine for enhanced context awareness")

	// Add alias for the command
	whatCmd.Aliases = []string{"w", "changes"}

	rootCmd.AddCommand(whatCmd)
}
```
## ./cmd/root.go
```
// cmd/root.go

package cmd

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/internal/llm"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

func runRootCommand(cmd *cobra.Command, args []string) {
	color.Cyan("[PRBuddy-Go] Starting...\n")

	initialized, err := isInitialized()
	if err != nil {
		color.Red("Error checking initialization status: %v\n", err)
		os.Exit(1)
	}

	if initialized {
		runInteractiveSession()
	} else {
		showInitialMenu()
	}
}

func runInteractiveSession() {
	color.Green("\nPRBuddy-Go is initialized in this repository.\n")

	fmt.Println(bold("Available Commands:"))
	fmt.Printf("   %s    - %s\n", green("generate pr"), "Generate a draft pull request")
	fmt.Printf("   %s    - %s\n", green("what changed"), "Show changes since the last commit")
	fmt.Printf("   %s    - %s\n", green("quickassist"), "Open a persistent chat session with the assistant")
	fmt.Printf("   %s    - %s\n", green("dce"), "Dynamic Context Engine")
	fmt.Printf("   %s    - %s\n", green("context save"), "Save current conversation context")
	fmt.Printf("   %s    - %s\n", green("context load"), "Reload saved context for current branch/commit")
	fmt.Printf("   %s    - %s\n", green("serve"), "Start API server for extension integration")
	fmt.Printf("   %s    - %s\n", green("map"), "Generate project scaffolds")
	fmt.Printf("   %s    - %s\n", green("help"), "Show help information")
	fmt.Printf("   %s    - %s\n", red("remove"), "Uninstall PRBuddy-Go and delete all associated files")
	fmt.Printf("   %s    - %s\n", green("exit"), "Exit the tool")

	reader := bufio.NewReader(os.Stdin)

	for {
		fmt.Printf("\n%s ", cyan(">"))
		input, err := reader.ReadString('\n')
		if err != nil {
			color.Red("Error reading input: %v\n", err)
			continue
		}

		parts := strings.Fields(strings.TrimSpace(input))
		if len(parts) == 0 {
			continue
		}

		command := strings.ToLower(parts[0])
		args := parts[1:]

		switch command {
		case "generate", "gen", "pr":
			handleGeneratePR()
		case "what", "w", "changes":
			handleWhatChanged()
		case "quickassist", "qa":
			handleQuickAssist(args, reader)
		case "dce":
			handleDCECommand()
		case "serve", "s":
			handleServeCommand()
		case "map":
			handleMapCommand()
		case "context":
			if len(args) < 1 {
				color.Red("Usage: context [save|load]")
				continue
			}
			switch args[0] {
			case "save":
				handleContextSave()
			case "load":
				handleContextLoad()
			default:
				color.Red("Unknown context subcommand. Use 'save' or 'load'.")
			}
		case "help", "h":
			printInteractiveHelp()
		case "remove", "uninstall":
			handleRemoveCommand()
		case "exit", "e", "quit", "q":
			color.Cyan("Exiting...\n")
			return
		default:
			color.Red("Unknown command. Type 'help' for available commands.\n")
		}
	}
}

func handleGeneratePR() {
	color.Cyan("\n[PRBuddy-Go] Generating draft PR...\n")
	runPostCommit(nil, nil)
}

func handleWhatChanged() {
	color.Cyan("\n[PRBuddy-Go] Checking changes...\n")
	whatCmd.Run(nil, nil)
}

func handleQuickAssist(args []string, reader *bufio.Reader) {
	if len(args) > 0 {
		singleQueryResponse(strings.Join(args, " "))
		return
	}
	startInteractiveQuickAssist(reader)
}

func singleQueryResponse(query string) {
	if query == "" {
		color.Red("No question provided.\n")
		return
	}

	resp, err := llm.HandleQuickAssist("", query)
	if err != nil {
		color.Red("Error: %v\n", err)
		return
	}

	color.Yellow("\nQuickAssist Response:\n")
	color.Cyan(resp)
	fmt.Println()
}

func startInteractiveQuickAssist(reader *bufio.Reader) {
	color.Cyan("\n[PRBuddy-Go] Quick Assist - Interactive Mode")
	color.Yellow("Type 'exit' or 'q' to end the session.\n")

	conversationID := ""

	for {
		color.Green("\nYou:")
		fmt.Print("> ")
		input, err := reader.ReadString('\n')
		if err != nil {
			color.Red("Error reading input: %v\n", err)
			continue
		}

		query := strings.TrimSpace(input)
		if shouldExit(query) {
			color.Cyan("\nEnding session.\n")
			return
		}

		if query == "" {
			color.Yellow("No question provided.\n")
			continue
		}

		resp, err := llm.HandleQuickAssist(conversationID, query)
		if err != nil {
			color.Red("Error: %v\n", err)
			continue
		}

		color.Blue("\nAssistant:\n")
		color.Cyan(resp)
		fmt.Println()

		if conv, exists := contextpkg.ConversationManagerInstance.GetConversation(conversationID); exists {
			conv.AddMessage("assistant", resp)
		}
	}
}

// cmd/what.go or wherever your command handlers are
func handleDCECommand() {
	color.Cyan("[PRBuddy-Go] Dynamic Context Engine - Interactive Mode")
	color.Yellow("Type 'exit' or 'q' to end the session.")

	// Initialize DCE
	dceInstance := dce.NewDCE()
	reader := bufio.NewReader(os.Stdin)

	color.Green("What are we working on today?")
	fmt.Print("> ")
	firstInput, err := reader.ReadString('\n')
	if err != nil {
		color.Red("Error reading input: %v", err)
		return
	}

	query := strings.TrimSpace(firstInput)
	if query == "" || query == "exit" || query == "q" {
		color.Red("No input provided. Exiting DCE.")
		return
	}

	// Activate DCE with the initial task
	if err := dceInstance.Activate(query); err != nil {
		color.Red("Error activating DCE: %v", err)
		return
	}

	// Get the conversation ID from the DCE context
	var conversationID string
	dce.GetDCEContextManager().ForEachContext(func(cid string, _ *dce.LittleGuy) {
		conversationID = cid
	})

	if conversationID == "" {
		color.Red("Failed to get conversation ID")
		return
	}

	// Interactive loop
	color.Green("DCE is active. Type your queries or DCE commands (/task, /status, etc.)")
	for {
		color.Green("You:")
		fmt.Print("> ")

		input, err := reader.ReadString('\n')
		if err != nil {
			color.Red("Error reading input: %v", err)
			break
		}

		input = strings.TrimSpace(input)
		if input == "exit" || input == "q" {
			break
		}

		// Check if it's a DCE command
		littleguy, _ := dce.GetDCEContextManager().GetContext(conversationID)
		if littleguy != nil && dce.HandleDCECommandMenu(input, littleguy) {
			continue
		}

		// Process as regular query
		response, err := llm.HandleDCERequest(conversationID, input)
		if err != nil {
			color.Red("Error processing request: %v", err)
			continue
		}

		color.Cyan("Assistant:")
		fmt.Println(response)
	}

	// Deactivate DCE
	dceInstance.Deactivate(conversationID)
	color.Cyan("DCE deactivated. Exiting.")
}

func handleMapCommand() {
	mapCmd.Run(nil, nil)
}

func handleServeCommand() {
	color.Cyan("\n[PRBuddy-Go] Starting API server...\n")
	llm.ServeCmd.Run(nil, nil)
}

func handleRemoveCommand() {
	color.Red("\nâš  WARNING: This will remove PRBuddy-Go from your repository! âš ")
	color.Yellow("Are you sure? Type 'yes' to confirm: ")

	reader := bufio.NewReader(os.Stdin)
	confirmation, _ := reader.ReadString('\n')
	confirmation = strings.TrimSpace(strings.ToLower(confirmation))

	if confirmation != "yes" {
		color.Cyan("Operation cancelled.")
		return
	}

	color.Red("\n[PRBuddy-Go] Removing PRBuddy-Go from the repository...\n")
	removeCmd.Run(nil, nil)
	color.Green("\n[PRBuddy-Go] Successfully uninstalled.\n")
}

func handleContextSave() {
	branch, err := utils.GetCurrentBranch()
	if err != nil {
		color.Red("Error getting branch: %v", err)
		return
	}
	commit, err := utils.GetLatestCommit()
	if err != nil {
		color.Red("Error getting commit hash: %v", err)
		return
	}

	conv, exists := contextpkg.ConversationManagerInstance.GetConversation("")
	if !exists {
		color.Yellow("No active conversation to save.\n")
		return
	}

	if err := llm.SaveDraftContext(branch, commit, conv.BuildContext()); err != nil {
		color.Red("Failed to save context: %v", err)
		return
	}
	color.Green("Conversation context saved for %s @ %s\n", branch, commit[:7])
}

func handleContextLoad() {
	branch, err := utils.GetCurrentBranch()
	if err != nil {
		color.Red("Error getting branch: %v", err)
		return
	}
	commit, err := utils.GetLatestCommit()
	if err != nil {
		color.Red("Error getting commit hash: %v", err)
		return
	}

	context, err := llm.LoadDraftContext(branch, commit)
	if err != nil {
		color.Red("Failed to load context: %v", err)
		return
	}

	conv := contextpkg.ConversationManagerInstance.StartConversation("", "", false)
	conv.SetMessages(context)
	color.Green("Context loaded for %s @ %s.\n", branch, commit[:7])
}

func joinMessages(msgs []contextpkg.Message) string {
	var sb strings.Builder
	caser := cases.Title(language.English)
	for _, m := range msgs {
		sb.WriteString(caser.String(m.Role))
		sb.WriteString(": ")
		sb.WriteString(m.Content)
		sb.WriteString("\n\n")
	}
	return sb.String()
}

func shouldExit(query string) bool {
	return strings.EqualFold(query, "exit") ||
		strings.EqualFold(query, "q") ||
		strings.EqualFold(query, "quit")
}

func printInitialHelp() {
	fmt.Println(bold("\nInitial Setup Commands:"))
	fmt.Printf("   %s    - %s\n", green("init"), "Initialize PRBuddy-Go in the current repository")
	fmt.Printf("   %s    - %s\n", green("help"), "Show this help information")
	fmt.Printf("   %s    - %s\n", green("exit"), "Exit the tool")
}

func printInteractiveHelp() {
	fmt.Println(bold("\nPull Request Workflow"))
	fmt.Printf("   %s    - %s\n", green("generate pr"), "Draft a new pull request with AI assistance")
	fmt.Printf("   %s    - %s\n", green("what changed"), "Show changes since your last commit")

	fmt.Println(bold("\nAssistant Tools"))
	fmt.Printf("   %s    - %s\n", green("quickassist"), "Chat live with the assistant (no memory)")
	fmt.Printf("   %s    - %s\n", green("dce"), "Enable Dynamic Context Engine (monitors task context)")
	fmt.Printf("   %s    - %s\n", green("context save"), "Save current conversation context")
	fmt.Printf("   %s    - %s\n", green("context load"), "Reload saved context for current branch/commit")

	fmt.Println(bold("\nProject Utilities"))
	fmt.Printf("   %s    - %s\n", green("map"), "Generate starter scaffolds for your project")
	fmt.Printf("   %s    - %s\n", green("serve"), "Start API server (for editor integration)")

	fmt.Println(bold("\nSystem"))
	fmt.Printf("   %s    - %s\n", green("help"), "Show this help information")
	fmt.Printf("   %s    - %s\n", red("remove"), "Uninstall PRBuddy-Go from this repository")
	fmt.Printf("   %s    - %s\n", green("exit"), "Exit the CLI")
}

func showInitialMenu() {
	color.Yellow("\nPRBuddy-Go is not initialized in this repository.\n")

	fmt.Println(bold("Available Commands:"))
	fmt.Printf("   %s    - %s\n", green("init"), "Initialize PRBuddy-Go in the current repository")
	fmt.Printf("   %s    - %s\n", green("help"), "Show help information")
	fmt.Printf("   %s    - %s\n", green("exit"), "Exit the tool")

	reader := bufio.NewReader(os.Stdin)

	for {
		fmt.Printf("\n%s ", cyan(">"))
		input, err := reader.ReadString('\n')
		if err != nil {
			color.Red("Error reading input: %v\n", err)
			continue
		}

		command := strings.TrimSpace(strings.ToLower(input))

		switch command {
		case "init", "i":
			initCmd.Run(nil, nil)
			return
		case "help", "h":
			printInitialHelp()
		case "exit", "e", "quit", "q":
			color.Cyan("Exiting...\n")
			return
		default:
			color.Red("Unknown command. Type 'help' for available commands.\n")
		}
	}
}
```
## ./main.go
```
// main.go

package main

import "github.com/soyuz43/prbuddy-go/cmd"

func main() {
	cmd.Execute()
}
```
## ./internal/treesitter/treesitter.go
```
package treesitter

// treesitter.go serves as the package entry point and re-exports commonly used functionality.

// For example, you can re-export the NewDummyParser function:
var NewParser = NewGoParser

// You can also re-export update triggers if desired.
// (Clients of this package can call treesitter.OnCommit, etc.)
```
## ./internal/treesitter/saver.go
```
package treesitter

import (
	"fmt"
	"time"

	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// -----------------------------------------------------------------------------
// Output Path Helpers
// -----------------------------------------------------------------------------

// getMetadataOutputPath returns the output path for the metadata file.
// If branchName is provided, it includes the branch name in the filename.
// Otherwise, it falls back to the format: project_metadata-<month>-<day>.json
func getMetadataOutputPath(branchName string) string {
	now := time.Now()
	if branchName != "" {
		return fmt.Sprintf(".git/pr_buddy_db/scaffold/project_metadata-%s-%02d-%02d.json", branchName, now.Month(), now.Day())
	}
	return fmt.Sprintf(".git/pr_buddy_db/scaffold/project_metadata-%02d-%02d.json", now.Month(), now.Day())
}

// getProjectMapOutputPath returns the output path for the project map file.
// If branchName is provided, it includes the branch name in the filename.
func getProjectMapOutputPath(branchName string) string {
	now := time.Now()
	if branchName != "" {
		return fmt.Sprintf(".git/pr_buddy_db/scaffold/project_map-%s-%02d-%02d.json", branchName, now.Month(), now.Day())
	}
	return fmt.Sprintf(".git/pr_buddy_db/scaffold/project_map-%02d-%02d.json", now.Month(), now.Day())
}

// -----------------------------------------------------------------------------
// Saving Functions (Using utils.WriteFile and utils.MarshalJSON)
// -----------------------------------------------------------------------------

// SaveMetadata writes the given metadata to a JSON file using atomic file writes.
func SaveMetadata(metadata *ProjectMetadata, branchName string) error {
	// Use the utils.MarshalJSON function to get a pretty-printed JSON string.
	jsonStr, err := utils.MarshalJSON(metadata)
	if err != nil {
		return fmt.Errorf("failed to marshal project metadata: %w", err)
	}
	data := []byte(jsonStr)
	outputPath := getMetadataOutputPath(branchName)
	return utils.WriteFile(outputPath, data)
}

// SaveProjectMap writes the given project map to a JSON file using atomic file writes.
func SaveProjectMap(projectMap *ProjectMap, branchName string) error {
	jsonStr, err := utils.MarshalJSON(projectMap)
	if err != nil {
		return fmt.Errorf("failed to marshal project map: %w", err)
	}
	data := []byte(jsonStr)
	outputPath := getProjectMapOutputPath(branchName)
	return utils.WriteFile(outputPath, data)
}
```
## ./internal/treesitter/watcher.go
```
package treesitter

import (
	"fmt"
	"log"

	"github.com/fsnotify/fsnotify"
	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// WatchFiles sets up file watchers on files that are relevant to the active tasks.
// It uses fsnotify to monitor for changes and logs detected changes.
// This function does not update the task list.
func WatchFiles(conversationID string) {
	conversation, exists := contextpkg.ConversationManagerInstance.GetConversation(conversationID)
	if !exists {
		fmt.Println("No active conversation found.")
		return
	}

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}
	defer watcher.Close()

	// Add each file from the current task list to the watcher.
	for _, task := range conversation.Tasks {
		for _, file := range task.Files {
			fmt.Printf("[Watcher] Verifying watcher for file: %s\n", file)
			err = watcher.Add(file)
			if err != nil {
				fmt.Printf("[Watcher] Error adding file %s to watcher: %v\n", file, err)
			}
		}
	}

	// Process file events.
	for {
		select {
		case event, ok := <-watcher.Events:
			if !ok {
				return
			}
			if event.Op&(fsnotify.Write|fsnotify.Create) != 0 {
				fmt.Printf("[Watcher] Detected change in: %s\n", event.Name)
				// This function is observational only.
			}
		case err, ok := <-watcher.Errors:
			if !ok {
				return
			}
			fmt.Println("[Watcher] Error:", err)
		}
	}
}

// CheckForUnstagedChanges checks for unstaged changes using git diff and logs them.
func CheckForUnstagedChanges(conversationID string) {
	_, exists := contextpkg.ConversationManagerInstance.GetConversation(conversationID)
	if !exists {
		fmt.Println("No active conversation found.")
		return
	}

	diffOutput, err := utils.ExecGit("diff", "--name-only")
	if err != nil {
		fmt.Println("Failed to retrieve git diff:", err)
		return
	}

	changedFiles := utils.SplitLines(diffOutput)
	if len(changedFiles) == 0 {
		fmt.Println("No unstaged changes detected.")
		return
	}

	// Log the unstaged files.
	for _, file := range changedFiles {
		fmt.Printf("[Watcher] Unstaged change detected: %s\n", file)
	}
}

// CheckForUntrackedFiles detects new untracked files and logs them.
// It does not update the task list.
func CheckForUntrackedFiles() {
	diffOutput, err := utils.ExecGit("ls-files", "--others", "--exclude-standard")
	if err != nil {
		fmt.Println("Failed to retrieve untracked files:", err)
		return
	}

	untrackedFiles := utils.SplitLines(diffOutput)
	if len(untrackedFiles) == 0 {
		fmt.Println("No untracked files detected.")
		return
	}

	// Log untracked files.
	for _, file := range untrackedFiles {
		fmt.Printf("[Watcher] New untracked file detected: %s\n", file)
	}
}
```
## ./internal/treesitter/updater.go
```
package treesitter

import (
	"fmt"
)

// -----------------------------------------------------------------------------
// Project Knowledge Update Functions & Triggers
// -----------------------------------------------------------------------------

// RefreshProjectKnowledge rebuilds the project metadata and map and saves them.
// The branchName parameter allows for branch-specific storage if desired.
func RefreshProjectKnowledge(rootDir, branchName string) error {
	parser := NewGoParser()

	// Build metadata.
	metadata, err := parser.BuildProjectMetadata(rootDir)
	if err != nil {
		return fmt.Errorf("failed to build project metadata: %w", err)
	}
	if err := SaveMetadata(metadata, branchName); err != nil {
		return fmt.Errorf("failed to save project metadata: %w", err)
	}

	// Build project map.
	projectMap, err := parser.BuildProjectMap(rootDir)
	if err != nil {
		return fmt.Errorf("failed to build project map: %w", err)
	}
	if err := SaveProjectMap(projectMap, branchName); err != nil {
		return fmt.Errorf("failed to save project map: %w", err)
	}

	fmt.Println("Project knowledge refreshed successfully.")
	return nil
}

// OnCommit is called on git commit. It triggers a refresh of the project map.
func OnCommit(rootDir, branchName string) error {
	fmt.Println("Trigger: OnCommit - Refreshing project map.")
	return RefreshProjectKnowledge(rootDir, branchName)
}

// OnPull is called on git pull. It triggers a refresh to sync remote changes.
func OnPull(rootDir, branchName string) error {
	fmt.Println("Trigger: OnPull - Refreshing project map.")
	return RefreshProjectKnowledge(rootDir, branchName)
}

// OnMerge is called on git merge. It refreshes the project map to capture new changes.
func OnMerge(rootDir, branchName string) error {
	fmt.Println("Trigger: OnMerge - Refreshing project map.")
	return RefreshProjectKnowledge(rootDir, branchName)
}

// OnCheckout is called on git checkout. The map should reflect the new branch state.
func OnCheckout(rootDir, branchName string) error {
	fmt.Println("Trigger: OnCheckout - Refreshing project map.")
	return RefreshProjectKnowledge(rootDir, branchName)
}

// ManualRefresh allows a manual request (e.g., via a /refresh-map command) to update the map.
func ManualRefresh(rootDir, branchName string) error {
	fmt.Println("Trigger: ManualRefresh - Refreshing project map.")
	return RefreshProjectKnowledge(rootDir, branchName)
}
```
## ./internal/treesitter/parser_orchestrator.go
```
// internal/treesitter/parser_orchestrator.go

package treesitter

import (
	"fmt"
)

// NewParserForLanguage returns the appropriate parser based on the provided language.
// For now, if lang is "go", it returns a GoParser. You can extend this function
// to support additional languages by adding new cases.
func NewParserForLanguage(rootDir string, lang Language) (Parser, error) {
	switch lang {
	case "go":
		return NewGoParser(), nil
		// Future extensions:
		// case "python":
		//     return NewPythonParser(), nil
		// case "javascript":
		//     return NewJavaScriptParser(), nil
	default:
		return nil, fmt.Errorf("unsupported language: %s", lang)
	}
}
```
## ./internal/treesitter/go_parser.go
```
package treesitter

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
	golang "github.com/smacker/go-tree-sitter/golang"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// -----------------------------------------------------------------------------
// Type Definitions (for Go parsing)
// -----------------------------------------------------------------------------

// Language represents a programming language.
type Language string

// ProjectMetadata holds project metadata including source files and ignored patterns.
type ProjectMetadata struct {
	Languages    []Language `json:"languages"`
	SourceFiles  []string   `json:"source_files"`
	IgnoredFiles []string   `json:"ignored_files"`
}

// FunctionDependencies tracks function relationships and invocations.
type FunctionDependencies struct {
	Handlers    []string `json:"handlers"`
	Utilities   []string `json:"utilities"`
	Invocations []string `json:"invocations"`
}

// FunctionInfo contains metadata about a Go function.
type FunctionInfo struct {
	Name         string               `json:"name"`
	File         string               `json:"file"`
	StartLine    int                  `json:"start_line"`
	EndLine      int                  `json:"end_line"`
	Returns      []string             `json:"returns"`
	Dependencies FunctionDependencies `json:"dependencies"`
}

// ProjectMap represents the complete project function mapping.
type ProjectMap struct {
	Functions []FunctionInfo `json:"functions"`
}

// Parser interface for project analysis operations.
type Parser interface {
	DetectLanguages(rootDir string) ([]Language, error)
	BuildProjectMetadata(rootDir string) (*ProjectMetadata, error)
	BuildProjectMap(rootDir string) (*ProjectMap, error)
}

// -----------------------------------------------------------------------------
// GoParser Implementation
// -----------------------------------------------------------------------------

// GoParser implements Parser for Go projects using Tree-sitter.
type GoParser struct {
	ignoredPatterns []*regexp.Regexp
}

// NewGoParser creates a new GoParser instance.
func NewGoParser() Parser {
	return &GoParser{}
}

// goParserState manages Tree-Sitter parsing state.
type goParserState struct {
	parser         *sitter.Parser
	functionQuery  *sitter.Query
	functionCursor *sitter.QueryCursor
}

// BuildProjectMap constructs a project map with function dependencies.
func (p *GoParser) BuildProjectMap(rootDir string) (*ProjectMap, error) {
	metadata, err := p.BuildProjectMetadata(rootDir)
	if err != nil {
		return nil, err
	}

	state, err := p.setupParserState()
	if err != nil {
		return nil, err
	}
	defer state.parser.Close()
	defer state.functionCursor.Close()

	var functions []FunctionInfo
	for _, file := range metadata.SourceFiles {
		fileFuncs, err := p.processGoFile(state, rootDir, file)
		if err != nil {
			continue // Skip problematic files but continue processing
		}
		functions = append(functions, fileFuncs...)
	}

	return &ProjectMap{Functions: functions}, nil
}

// setupParserState initializes Tree-Sitter components.
func (p *GoParser) setupParserState() (*goParserState, error) {
	parser := sitter.NewParser()
	parser.SetLanguage(golang.GetLanguage())

	funcQuery, err := sitter.NewQuery([]byte(`
(function_declaration
  name: (identifier) @name
  parameters: (parameter_list
    (parameter_declaration
      name: (identifier)? @param_name
      type: (_) @param_type
    )*
  ) @parameters
  result: (parameter_list
    (parameter_declaration
      name: (identifier)? @return_name
      type: (_) @return_type
    )*
  )? @results
  body: (block) @body
) @func
  `), golang.GetLanguage())
	if err != nil {
		return nil, fmt.Errorf("failed to create function query: %w", err)
	}

	return &goParserState{
		parser:         parser,
		functionQuery:  funcQuery,
		functionCursor: sitter.NewQueryCursor(),
	}, nil
}

// processGoFile handles processing of individual Go files.
func (p *GoParser) processGoFile(state *goParserState, rootDir string, file string) ([]FunctionInfo, error) {
	absPath, err := p.resolveAbsPath(rootDir, file)
	if err != nil {
		return nil, err
	}

	content, err := os.ReadFile(absPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read %s: %w", absPath, err)
	}

	// Parse the file content into a syntax tree (CST) in memory.
	tree, err := state.parser.ParseCtx(context.Background(), nil, content)
	if err != nil || tree == nil {
		return nil, fmt.Errorf("failed to parse %s: %w", absPath, err)
	}

	// === Dump the syntax tree for inspection ===
	if err := saveSyntaxTree(file, tree, content); err != nil {
		fmt.Printf("Warning: Failed to save syntax tree for %s: %s\n", absPath, err)
	}

	// Extract function metadata and dependencies
	functions := p.parseFunctions(state, tree, content, file)

	return functions, nil
}

// parseFunctions extracts function declarations and dependencies from a parsed tree.
func (p *GoParser) parseFunctions(state *goParserState, tree *sitter.Tree, content []byte, file string) []FunctionInfo {
	var functions []FunctionInfo
	state.functionCursor.Exec(state.functionQuery, tree.RootNode())

	for {
		match, ok := state.functionCursor.NextMatch()
		if !ok {
			break
		}

		var funcInfo FunctionInfo
		var returns []string
		var bodyNode *sitter.Node

		// Process captures from the function query.
		for _, capture := range match.Captures {
			node := capture.Node
			switch state.functionQuery.CaptureNameForId(capture.Index) {
			case "name":
				funcInfo.Name = string(node.Content(content))
			case "return_type":
				returns = append(returns, string(node.Content(content)))
			case "body":
				bodyNode = node
				funcInfo.StartLine = int(node.Parent().StartPoint().Row) + 1
				funcInfo.EndLine = int(node.Parent().EndPoint().Row) + 1
			}
		}
		funcInfo.Returns = returns
		funcInfo.File = file

		// Initialize dependencies.
		funcInfo.Dependencies = FunctionDependencies{}

		// Extract function dependencies.
		if bodyNode != nil {
			depQuery, err := sitter.NewQuery([]byte(`
				(call_expression
					function: (identifier) @invocation
				)
			`), golang.GetLanguage())

			if err == nil {
				depCursor := sitter.NewQueryCursor()
				depCursor.Exec(depQuery, bodyNode)

				for {
					depMatch, ok := depCursor.NextMatch()
					if !ok {
						break
					}
					for _, depCapture := range depMatch.Captures {
						if depQuery.CaptureNameForId(depCapture.Index) == "invocation" {
							invocationName := string(depCapture.Node.Content(content))

							// Check if the function is locally defined in the same file (utility function).
							isUtility := false
							for _, f := range functions {
								if f.Name == invocationName {
									isUtility = true
									break
								}
							}

							// Categorize dependencies
							if strings.HasPrefix(invocationName, "Handle") {
								funcInfo.Dependencies.Handlers = append(funcInfo.Dependencies.Handlers, invocationName)
							} else if isUtility {
								funcInfo.Dependencies.Utilities = append(funcInfo.Dependencies.Utilities, invocationName)
							} else {
								funcInfo.Dependencies.Invocations = append(funcInfo.Dependencies.Invocations, invocationName)
							}
						}
					}
				}
			}
		}

		if funcInfo.Name != "" {
			functions = append(functions, funcInfo)
		}
	}

	return functions
}

// resolveAbsPath converts a relative path to an absolute path.
func (p *GoParser) resolveAbsPath(rootDir, file string) (string, error) {
	parts := strings.SplitN(file, "/", 3)
	if len(parts) < 3 {
		return filepath.Abs(file)
	}
	return filepath.Join(rootDir, parts[2]), nil
}

// DetectLanguages scans the project for .go files that are not ignored,
// and returns "go" if any are found.
func (p *GoParser) DetectLanguages(rootDir string) ([]Language, error) {
	var detected []Language

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
			if !utils.IsIgnored(path, p.ignoredPatterns) {
				detected = append(detected, "go")
				return filepath.SkipDir // Stop after detecting Go.
			}
		}
		return nil
	})

	if err != nil {
		return nil, err
	}
	return detected, nil
}

// BuildProjectMetadata scans for .go files (converting absolute paths
// to relative paths based on the repository's base name) and loads .gitignore patterns.
func (p *GoParser) BuildProjectMetadata(rootDir string) (*ProjectMetadata, error) {
	// Read .gitignore patterns.
	patterns, err := utils.ReadGitignore(rootDir)
	if err != nil {
		// If .gitignore doesn't exist or fails to open, proceed with no patterns.
		patterns = []*regexp.Regexp{}
	}
	p.ignoredPatterns = patterns

	var sourceFiles []string
	repoName := filepath.Base(rootDir)

	err = filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
			if !utils.IsIgnored(path, p.ignoredPatterns) {
				relPath, relErr := filepath.Rel(rootDir, path)
				if relErr == nil {
					// e.g., "/prbuddy-go/cmd/root.go"
					sourceFiles = append(sourceFiles, fmt.Sprintf("/%s/%s", repoName, relPath))
				} else {
					sourceFiles = append(sourceFiles, path)
				}
			}
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	metadata := &ProjectMetadata{
		Languages:    []Language{"go"},
		SourceFiles:  sourceFiles,
		IgnoredFiles: patternStrings(patterns),
	}
	return metadata, nil
}

// patternStrings converts a slice of compiled regexes to their string representations.
func patternStrings(patterns []*regexp.Regexp) []string {
	var out []string
	for _, pat := range patterns {
		out = append(out, pat.String())
	}
	return out
}

// -----------------------------------------------------------------------------
// Dump Tree Utilities
// -----------------------------------------------------------------------------

// dumpTree recursively builds an indented string representation of the syntax tree.
// It includes each node's type and its start/end positions.
func dumpTree(node *sitter.Node, source []byte, indent string) string {
	result := fmt.Sprintf("%s%s [%d:%d - %d:%d]\n",
		indent,
		node.Type(),
		node.StartPoint().Row, node.StartPoint().Column,
		node.EndPoint().Row, node.EndPoint().Column)
	for i := 0; i < int(node.ChildCount()); i++ {
		child := node.Child(i)
		result += dumpTree(child, source, indent+"  ")
	}
	return result
}

// saveSyntaxTree saves the full syntax tree to a file for inspection.
// The file is written to .git/prbuddy_db/scaffold/<filename>_tree.txt.
func saveSyntaxTree(file string, tree *sitter.Tree, source []byte) error {
	scaffoldDir := filepath.Join(".git", "prbuddy_db", "scaffold")
	if err := os.MkdirAll(scaffoldDir, 0755); err != nil {
		return fmt.Errorf("failed to create scaffold directory: %w", err)
	}
	outputFile := filepath.Join(scaffoldDir, filepath.Base(file)+"_tree.txt")
	treeDump := dumpTree(tree.RootNode(), source, "")
	if err := os.WriteFile(outputFile, []byte(treeDump), 0644); err != nil {
		return fmt.Errorf("failed to write syntax tree to file: %w", err)
	}
	return nil
}
```
## ./internal/contextpkg/context.go
```
// internal/contextpkg/context.go
package contextpkg

import (
	"fmt"
	"strings"
	"sync"
	"time"
)

// -----------------------------------------------------------------------------
// Chat Structures and LLM Context
// -----------------------------------------------------------------------------

// Message represents a chat message.
type Message struct {
	Role      string        `json:"role"`                 // e.g., "user", "assistant", "system"
	Content   string        `json:"content,omitempty"`    // The main text content
	Images    []string      `json:"images,omitempty"`     // Optional: image paths for multimodal models
	ToolCalls []interface{} `json:"tool_calls,omitempty"` // Optional: tool calls (if applicable)
}

// Task represents a unit of work.
type Task struct {
	Description  string   `json:"description"`
	Files        []string `json:"files"`
	Functions    []string `json:"functions"`
	Dependencies []string `json:"dependencies"`
	Notes        []string `json:"notes"`
}

// Conversation represents a single conversation thread.
type Conversation struct {
	ID             string
	Ephemeral      bool
	InitialDiff    string
	Messages       []Message
	Tasks          []Task
	LastActivity   time.Time
	DiffTruncation bool
	mutex          sync.RWMutex
	// Removed DCEContext *dce.LittleGuy to break import cycle
	IsActiveDCE bool // Track if DCE is active for this conversation
}

// ConversationManager manages multiple conversations.
type ConversationManager struct {
	conversations map[string]*Conversation
	mutex         sync.RWMutex
}

// NewConversationManager creates and returns a new ConversationManager.
func NewConversationManager() *ConversationManager {
	return &ConversationManager{
		conversations: make(map[string]*Conversation),
	}
}

// StartConversation creates a new conversation with the given id, initial diff, and ephemeral flag.
func (cm *ConversationManager) StartConversation(id, initialDiff string, ephemeral bool) *Conversation {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	conv := &Conversation{
		ID:           id,
		Ephemeral:    ephemeral,
		InitialDiff:  initialDiff,
		Messages:     make([]Message, 0),
		LastActivity: time.Now(),
	}
	cm.conversations[id] = conv
	return conv
}

// GetConversation retrieves an existing conversation by id.
func (cm *ConversationManager) GetConversation(id string) (*Conversation, bool) {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	conv, exists := cm.conversations[id]
	return conv, exists
}

// RemoveConversation removes a conversation from memory.
func (cm *ConversationManager) RemoveConversation(id string) {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()
	delete(cm.conversations, id)
}

// Cleanup removes conversations that have been inactive for longer than maxAge.
func (cm *ConversationManager) Cleanup(maxAge time.Duration) {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	now := time.Now()
	for id, conv := range cm.conversations {
		if now.Sub(conv.LastActivity) > maxAge {
			delete(cm.conversations, id)
		}
	}
}

// AddMessage appends a new message to the conversation.
func (c *Conversation) AddMessage(role, content string) {
	c.mutex.Lock()
	defer c.mutex.Unlock()
	c.Messages = append(c.Messages, Message{
		Role:    role,
		Content: content,
	})
	c.LastActivity = time.Now()
}

// BuildContext constructs the conversation context to be sent to the LLM.
func (c *Conversation) BuildContext() []Message {
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	context := []Message{
		{
			Role:    "system",
			Content: "You are a developer assistant.",
		},
	}
	context = append(context, c.Messages...)
	return context
}

// SetMessages replaces the conversation's messages with the provided slice.
func (c *Conversation) SetMessages(newMessages []Message) {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	c.Messages = newMessages
	c.LastActivity = time.Now()
}

// GenerateConversationID creates a unique conversation ID using the given prefix.
func GenerateConversationID(prefix string) string {
	return fmt.Sprintf("%s-%d", prefix, time.Now().UnixNano())
}

// TruncateDiff reduces the diff size to at most maxLines while preserving key information.
func TruncateDiff(diff string, maxLines int) string {
	lines := strings.Split(strings.TrimSuffix(diff, "\n"), "\n")
	if len(lines) <= maxLines {
		return diff
	}
	return strings.Join(lines[:maxLines], "\n")
}

// ConversationManagerInstance is a global singleton instance of ConversationManager.
var ConversationManagerInstance = NewConversationManager()

// -----------------------------------------------------------------------------
// Global LLM Model State
// -----------------------------------------------------------------------------

var (
	modelMutex     sync.RWMutex
	activeLLMModel string
)

// SetActiveModel sets the currently active model name (thread-safe).
func SetActiveModel(model string) {
	modelMutex.Lock()
	defer modelMutex.Unlock()
	activeLLMModel = model
}

// GetActiveModel retrieves the current model name (thread-safe).
func GetActiveModel() string {
	modelMutex.RLock()
	defer modelMutex.RUnlock()
	return activeLLMModel
}
```
## ./internal/llm/server.go
```
// internal/llm/server.go

package llm

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/utils"
	"github.com/spf13/cobra"
)

// Global model config in memory

const (
	defaultHost              = "localhost"
	defaultInactivityTimeout = 30 * time.Minute
	shutdownGracePeriod      = 5 * time.Second
)

type ServerConfig struct {
	Host              string
	InactivityTimeout time.Duration
}

// StartServer initializes and runs the HTTP server with full lifecycle management
func StartServer(cfg ServerConfig) error {
	if err := utils.EnsureAppCacheDir(); err != nil {
		return fmt.Errorf("cache directory initialization failed: %w", err)
	}

	listener, err := net.Listen("tcp", cfg.Host+":0")
	if err != nil {
		return fmt.Errorf("failed to create listener: %w", err)
	}

	port := listener.Addr().(*net.TCPAddr).Port
	if err := utils.WritePortFile(port); err != nil {
		return fmt.Errorf("port file write failed: %w", err)
	}

	router := http.NewServeMux()
	registerHandlers(router)

	server := &http.Server{
		Addr:    fmt.Sprintf("%s:%d", cfg.Host, port),
		Handler: router,
	}

	return manageServerLifecycle(server, listener, cfg.InactivityTimeout)
}

func registerHandlers(router *http.ServeMux) {
	router.HandleFunc("/quickassist", quickAssistHandler())
	router.HandleFunc("/dce", dceHandler())
	router.HandleFunc("/quickassist/clear", quickAssistClearHandler())
	router.HandleFunc("/extension/drafts", saveDraftHandler())
	router.HandleFunc("/extension/drafts/load", loadDraftHandler())
	router.HandleFunc("/what", whatHandler())
	router.HandleFunc("/extension/models", listModelsHandler())
	router.HandleFunc("/extension/model", setModelHandler())
}

func manageServerLifecycle(server *http.Server, listener net.Listener, timeout time.Duration) error {
	shutdownChan := make(chan os.Signal, 1)
	signal.Notify(shutdownChan, os.Interrupt, syscall.SIGTERM)

	timeoutTimer := time.NewTimer(timeout)
	defer timeoutTimer.Stop()

	go func() {
		select {
		case <-shutdownChan:
			fmt.Println("\nReceived shutdown signal")
		case <-timeoutTimer.C:
			fmt.Println("Inactivity timeout reached")
		}

		ctx, cancel := context.WithTimeout(context.Background(), shutdownGracePeriod)
		defer cancel()

		_ = server.Shutdown(ctx)
	}()

	fmt.Printf("Server listening on %s\n", listener.Addr())
	if err := server.Serve(listener); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("server error: %w", err)
	}

	_ = utils.DeletePortFile()
	fmt.Println("Server shutdown completed successfully")
	return nil
}

// ServeCmd is the Cobra command to start the API server
var ServeCmd = &cobra.Command{
	Use:   "serve",
	Short: "Start API server for extension integration",
	Run: func(cmd *cobra.Command, args []string) {
		cfg := ServerConfig{
			Host:              defaultHost,
			InactivityTimeout: defaultInactivityTimeout,
		}

		if err := StartServer(cfg); err != nil {
			fmt.Printf("Server startup failed: %v\n", err)
			os.Exit(1)
		}
	},
}

// Request/Response types
type (
	QuickAssistRequest struct {
		ConversationID string `json:"conversationId"`
		Input          string `json:"input"`
	}

	DCERequest struct {
		ConversationID string `json:"conversationId"`
		Input          string `json:"input"`
	}

	ClearRequest struct {
		ConversationID string `json:"conversationId"`
	}

	DraftSaveRequest struct {
		Branch   string               `json:"branch"`
		Commit   string               `json:"commit"`
		Messages []contextpkg.Message `json:"messages"`
	}

	DraftLoadRequest struct {
		Branch string `json:"branch"`
		Commit string `json:"commit"`
	}

	ModelRequest struct {
		Model string `json:"model"`
	}
)

// Handlers
func quickAssistHandler() http.HandlerFunc {
	return JSONHandler(func(req QuickAssistRequest) (any, error) {
		return HandleQuickAssist(req.ConversationID, req.Input)
	})
}

func dceHandler() http.HandlerFunc {
	return JSONHandler(func(req DCERequest) (any, error) {
		return HandleDCERequest(req.ConversationID, req.Input)
	})
}

func quickAssistClearHandler() http.HandlerFunc {
	return JSONHandler(func(req ClearRequest) (any, error) {
		if req.ConversationID == "" {
			return nil, fmt.Errorf("conversationId is required")
		}
		contextpkg.ConversationManagerInstance.RemoveConversation(req.ConversationID)
		return map[string]string{"status": "cleared"}, nil
	})
}

func saveDraftHandler() http.HandlerFunc {
	return JSONHandler(func(req DraftSaveRequest) (any, error) {
		if req.Branch == "" || req.Commit == "" {
			return nil, fmt.Errorf("branch and commit are required")
		}
		if len(req.Messages) == 0 {
			return nil, fmt.Errorf("messages are required")
		}
		if err := SaveDraftContext(req.Branch, req.Commit, req.Messages); err != nil {
			return nil, err
		}
		return map[string]string{"status": "success"}, nil
	})
}

func loadDraftHandler() http.HandlerFunc {
	return JSONHandler(func(req DraftLoadRequest) (any, error) {
		context, err := LoadDraftContext(req.Branch, req.Commit)
		if err != nil {
			return nil, err
		}
		return map[string]interface{}{"status": "success", "messages": context}, nil
	})
}

func whatHandler() http.HandlerFunc {
	return JSONHandler(func(_ struct{}) (any, error) {
		summary, err := GenerateWhatSummary()
		return map[string]string{"summary": summary}, err
	})
}

func listModelsHandler() http.HandlerFunc {
	return JSONHandler(func(_ struct{}) (any, error) {
		endpoint := os.Getenv("PRBUDDY_LLM_ENDPOINT")
		if endpoint == "" {
			endpoint = "http://localhost:11434"
		}
		return fetchOllamaModels(endpoint)
	})
}

func setModelHandler() http.HandlerFunc {
	return JSONHandler(func(req ModelRequest) (any, error) {
		if req.Model == "" {
			return nil, fmt.Errorf("missing 'model' field")
		}
		contextpkg.SetActiveModel(req.Model)
		return map[string]string{
			"status":       "model updated",
			"active_model": contextpkg.GetActiveModel(),
		}, nil
	})
}
```
## ./internal/llm/draft_context.go
```
// internal/llm/draft_context.go

package llm

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// SaveDraftContext saves conversation messages to disk for a specific branch/commit
func SaveDraftContext(branchName, commitHash string, context []contextpkg.Message) error {
	repoPath, err := utils.GetRepoPath()
	if err != nil {
		return fmt.Errorf("failed to get repository path: %w", err)
	}

	sanitizedBranch := utils.SanitizeBranchName(branchName)
	commitDir := filepath.Join(repoPath, ".git", "pr_buddy_db",
		fmt.Sprintf("%s-%s", sanitizedBranch, commitHash[:7]))

	if err := os.MkdirAll(commitDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	draftContextJSON, err := utils.MarshalJSON(context)
	if err != nil {
		return fmt.Errorf("failed to marshal draft context: %w", err)
	}

	if err := saveFile(commitDir, "draft_context.json", string(draftContextJSON)); err != nil {
		return fmt.Errorf("failed to save draft context: %w", err)
	}

	return nil
}

// LoadDraftContext retrieves saved conversation context for a specific branch/commit
func LoadDraftContext(branchName, commitHash string) ([]contextpkg.Message, error) {
	repoPath, err := utils.GetRepoPath()
	if err != nil {
		return nil, fmt.Errorf("failed to get repository path: %w", err)
	}

	sanitizedBranch := utils.SanitizeBranchName(branchName)
	filePath := filepath.Join(repoPath, ".git", "pr_buddy_db",
		fmt.Sprintf("%s-%s", sanitizedBranch, commitHash[:7]), "draft_context.json")

	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read draft context file: %w", err)
	}

	var context []contextpkg.Message
	if err := json.Unmarshal(data, &context); err != nil {
		return nil, fmt.Errorf("failed to unmarshal draft context: %w", err)
	}

	return context, nil
}

// saveFile writes content to a specified file within a directory
func saveFile(dir, filename, content string) error {
	path := filepath.Join(dir, filename)
	if err := utils.WriteFile(path, []byte(content)); err != nil {
		return fmt.Errorf("file write failed: %w", err)
	}

	return nil
}
```
## ./internal/llm/middleware.go
```
// ./llm/middleware.go
package llm

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// JSONHandler creates a handler for JSON requests/responses with unified error handling
func JSONHandler[T any](logic func(T) (any, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Set content type first
		w.Header().Set("Content-Type", "application/json")

		// Validate HTTP method
		if r.Method != http.MethodPost {
			writeError(w, fmt.Sprintf("Method %s not allowed", r.Method), http.StatusMethodNotAllowed)
			return
		}

		// Decode request
		var req T
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			writeError(w, "Invalid request format", http.StatusBadRequest)
			return
		}

		// Execute handler logic
		response, err := logic(req)
		if err != nil {
			writeError(w, err.Error(), http.StatusInternalServerError)
			return
		}

		// Marshal response
		jsonResponse, err := utils.MarshalJSON(response)
		if err != nil {
			writeError(w, "Failed to marshal response", http.StatusInternalServerError)
			return
		}

		w.WriteHeader(http.StatusOK)
		w.Write([]byte(jsonResponse))
	}
}

// writeError handles error responses consistently
func writeError(w http.ResponseWriter, message string, code int) {
	log.Printf("HTTP %d: %s", code, message)
	w.WriteHeader(code)
	errorResponse := map[string]string{"error": message}
	if jsonErr, err := utils.MarshalJSON(errorResponse); err == nil {
		w.Write([]byte(jsonErr))
	}
}
```
## ./internal/llm/llm_client.go
```
// internal/llm/llm_client.go

package llm

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/dce"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

//------------------------------------------------------------------------------
// LLMClient INTERFACE + DEFAULT IMPLEMENTATION
//------------------------------------------------------------------------------

// LLMClient defines the interface for interacting with the LLM (Ollama).
type LLMClient interface {
	// For non-streaming calls
	GetChatResponse(messages []contextpkg.Message) (string, error)
	// For streaming calls (accumulate chunks under the hood)
	StreamChatResponse(messages []contextpkg.Message) (<-chan string, error)
}

// DefaultLLMClient implements the LLMClient interface using Ollamaâ€™s /api/chat.
type DefaultLLMClient struct{}

//------------------------------------------------------------------------------
// NON-STREAMING METHOD: GetChatResponse
//------------------------------------------------------------------------------

func (c *DefaultLLMClient) GetChatResponse(messages []contextpkg.Message) (string, error) {
	model, endpoint := GetLLMConfig()

	// Request body: force "stream": false
	requestBody := map[string]interface{}{
		"model":    model,
		"messages": messages,
		"options": map[string]interface{}{
			"num_ctx": 8192,
		},
		"stream": false,
	}

	jsonBody, err := utils.MarshalJSON(requestBody)
	if err != nil {
		return "", errors.Wrap(err, "failed to marshal request body")
	}

	resp, err := http.Post(endpoint+"/api/chat", "application/json", strings.NewReader(jsonBody))
	if err != nil {
		return "", errors.Wrap(err, "failed to send POST request to LLM")
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("LLM responded with status code %d", resp.StatusCode)
	}

	var llmResp LLMResponse
	if err := json.NewDecoder(resp.Body).Decode(&llmResp); err != nil {
		return "", errors.Wrap(err, "failed to decode LLM response")
	}

	if llmResp.Message.Content == "" {
		return "", fmt.Errorf("empty response from LLM")
	}

	logrus.Info("Received response from LLM successfully (non-stream).")
	return llmResp.Message.Content, nil
}

//------------------------------------------------------------------------------
// STREAMING METHOD: StreamChatResponse
//------------------------------------------------------------------------------

// StreamChatResponse reads lines from Ollamaâ€™s /api/chat as soon as they arrive.
// Each line is expected to be a complete JSON object. When "done" = true, we stop.
func (c *DefaultLLMClient) StreamChatResponse(messages []contextpkg.Message) (<-chan string, error) {
	model, endpoint := GetLLMConfig()

	reqBody := map[string]interface{}{
		"model":    model,
		"messages": messages,
		"stream":   true,
		"options": map[string]interface{}{
			"num_ctx": 8192,
		},
	}

	jsonData, err := json.Marshal(reqBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request body: %w", err)
	}

	req, err := http.NewRequest("POST", endpoint+"/api/chat", bytes.NewReader(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	// Execute HTTP request
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf("non-200 status code: %d", resp.StatusCode)
	}

	outChan := make(chan string)

	go func() {
		defer resp.Body.Close()
		defer close(outChan)

		scanner := bufio.NewScanner(resp.Body)
		for scanner.Scan() {
			line := scanner.Text()
			if line == "" {
				continue
			}

			var chunk OllamaStreamChunk
			if err := json.Unmarshal([]byte(line), &chunk); err != nil {
				// Log parse errors but keep going
				logrus.Errorf("Failed to unmarshal streaming chunk: %v", err)
				continue
			}

			// If "done" is true, streaming has ended
			if chunk.Done {
				break
			}

			// Send content if present
			if chunk.Message != nil && chunk.Message.Content != "" {
				outChan <- chunk.Message.Content
			}
		}

		// If there's a scanning error, log it
		if err := scanner.Err(); err != nil {
			logrus.Errorf("Scanner error while reading streaming response: %v", err)
		}
	}()

	return outChan, nil
}

//------------------------------------------------------------------------------
// DATA STRUCTS & GLOBAL
//------------------------------------------------------------------------------

// LLMResponse represents the top-level structure from Ollama (non-streaming).
type LLMResponse struct {
	Message struct {
		Content string `json:"content"`
	} `json:"message"`
}

// OllamaStreamChunk is used during streaming (partial response).
type OllamaStreamChunk struct {
	Model   string `json:"model,omitempty"`
	Message *struct {
		Role    string   `json:"role,omitempty"`
		Content string   `json:"content,omitempty"`
		Images  []string `json:"images,omitempty"`
	} `json:"message,omitempty"`
	Done bool `json:"done,omitempty"`
}

// llmClient is the global instance implementing LLMClient.
var llmClient LLMClient = &DefaultLLMClient{}

// SetLLMClient allows injecting a different LLMClient (useful for testing or future extensions).
func SetLLMClient(client LLMClient) {
	llmClient = client
}

//------------------------------------------------------------------------------
// PUBLIC HANDLER FUNCTIONS
//------------------------------------------------------------------------------

// HandleQuickAssist returns the final LLM response for a persistent conversation,
// accumulating the streaming output behind-the-scenes into one string.
func HandleQuickAssist(conversationID, input string) (string, error) {
	if input == "" {
		return "", fmt.Errorf("no user message provided")
	}

	// Retrieve or create conversation
	conv, exists := contextpkg.ConversationManagerInstance.GetConversation(conversationID)
	if !exists {
		if conversationID == "" {
			conversationID = contextpkg.GenerateConversationID("persistent")
		}
		conv = contextpkg.ConversationManagerInstance.StartConversation(conversationID, "", false)
	}

	// 1) Add user's message
	conv.AddMessage("user", input)

	// 2) Build final context for LLM
	context := conv.BuildContext()

	// 3) Stream from LLM
	streamChan, err := llmClient.StreamChatResponse(context)
	if err != nil {
		return "", fmt.Errorf("failed to stream response: %w", err)
	}

	// 4) Collect the streaming chunks
	var builder strings.Builder
	for chunk := range streamChan {
		builder.WriteString(chunk)
	}
	finalResponse := builder.String()

	// 5) Store assistant's final response in conversation
	conv.AddMessage("assistant", finalResponse)

	return finalResponse, nil
}

// HandleDCERequest handles ephemeral (DCE-driven) requests, returning the final text
// from a fresh ephemeral conversation, after running your DCE logic.
func HandleDCERequest(conversationID, input string) (string, error) {
	if input == "" {
		return "", fmt.Errorf("no user message provided")
	}

	// Get or create ephemeral conversation
	conv, exists := contextpkg.ConversationManagerInstance.GetConversation(conversationID)
	if !exists {
		if conversationID == "" {
			conversationID = contextpkg.GenerateConversationID("ephemeral")
		}
		conv = contextpkg.ConversationManagerInstance.StartConversation(conversationID, "", true)
	}

	conv.AddMessage("user", input)

	// Initialize and use DCE
	dceInstance := dce.NewDCE()
	if err := dceInstance.Activate(input); err != nil {
		return "", fmt.Errorf("DCE activation failed: %w", err)
	}
	defer dceInstance.Deactivate(conversationID)

	// Build task list
	taskList, buildLogs, err := dceInstance.BuildTaskList(input)
	if err != nil {
		return "", fmt.Errorf("failed to build task list: %w", err)
	}

	fmt.Println("=== Task List ===")
	for i, task := range taskList {
		fmt.Printf("Task %d:\n", i+1)
		fmt.Printf("  Description: %s\n", task.Description)
		if len(task.Files) > 0 {
			fmt.Printf("  Files: %v\n", task.Files)
		}
		if len(task.Functions) > 0 {
			fmt.Printf("  Functions: %v\n", task.Functions)
		}
		if len(task.Dependencies) > 0 {
			fmt.Printf("  Dependencies: %v\n", task.Dependencies)
		}
		if len(task.Notes) > 0 {
			fmt.Printf("  Notes: %v\n", task.Notes)
		}
	}
	fmt.Println("==================")

	// Add build logs to conversation + console
	for _, logMsg := range buildLogs {
		conv.AddMessage("system", "[DCE] "+logMsg)
		fmt.Println("[DCE]", logMsg)
	}

	// Filter project data
	filteredData, filterLogs, err := dceInstance.FilterProjectData(taskList)
	if err != nil {
		return "", fmt.Errorf("failed to filter project data: %w", err)
	}
	for _, logMsg := range filterLogs {
		conv.AddMessage("system", "[DCE] "+logMsg)
		fmt.Println("[DCE]", logMsg)
	}

	// Augment conversation with filtered data
	augmentedContext := dceInstance.AugmentContext(conv.BuildContext(), filteredData)
	conv.SetMessages(augmentedContext)

	// Save expanded context for debugging
	if err := utils.SaveContextToFile(conv.ID, augmentedContext); err != nil {
		logrus.Errorf("Failed to save context to file: %v", err)
	}
	if err := utils.SaveConcatenatedContextToFile(conv.ID, augmentedContext); err != nil {
		logrus.Errorf("Failed to save concatenated context to file: %v", err)
	}

	// Build final context
	context := conv.BuildContext()

	// Retrieve response (non-streaming) from LLM
	response, err := llmClient.GetChatResponse(context)
	if err != nil {
		return "", fmt.Errorf("failed to get response from LLM: %w", err)
	}

	conv.AddMessage("assistant", response)
	return response, nil
}

// StartPRConversation initiates a new PR conversation with a commit message and diffs.
func StartPRConversation(commitMessage, diffs string) (string, string, error) {
	// Generate a conversation ID
	conversationID := fmt.Sprintf("pr-%d", time.Now().UnixNano())
	conv := contextpkg.ConversationManagerInstance.StartConversation(conversationID, diffs, false)

	prompt := fmt.Sprintf(`
You are an assistant designed to generate a detailed pull request (PR) description based on the following commit message and code changes.

**Commit Message:**
%s

**Code Changes:**
%s

!TASK: Provide a comprehensive PR title and description that explain the changes and adhere to documentation and GitHub best practices. Format the pull request in raw markdown with headers. Clearly separate the pull request and other components of the response with three backticks. In fact, wrap the entire output in triple backticks. The entire output must be a single raw markdown code block, with no additional commentary or explanation outside the code block. No emojis in output.
`, commitMessage, diffs)

	// Add initial user message
	conv.AddMessage("user", prompt)

	// Get initial response (non-streaming)
	response, err := llmClient.GetChatResponse(conv.BuildContext())
	if err != nil {
		return "", "", err
	}

	// Add assistant response
	conv.AddMessage("assistant", response)
	return conversationID, response, nil
}

// ContinuePRConversation reuses HandleQuickAssist for continuing a normal (persistent) PR conversation.
func ContinuePRConversation(conversationID, input string) (string, error) {
	return HandleQuickAssist(conversationID, input)
}

// GeneratePreDraftPR obtains the latest commit message and diff, then returns them for usage in PR creation.
func GeneratePreDraftPR() (string, string, error) {
	commitMsg, err := utils.ExecGit("log", "-1", "--pretty=%B")
	if err != nil {
		return "", "", errors.Wrap(err, "failed to get latest commit message")
	}
	diff, err := utils.ExecGit("diff", "HEAD~1", "HEAD")
	if err != nil {
		return "", "", errors.Wrap(err, "failed to get git diff")
	}

	// Intelligent truncation: prioritize added lines and metadata
	truncatedDiff := contextpkg.TruncateDiff(diff, 1000) // Adjust max lines as needed
	return commitMsg, truncatedDiff, nil
}

// GenerateDraftPR uses the LLM's chat endpoint to generate a PR draft (stateless).
func GenerateDraftPR(commitMessage, diffs string) (string, error) {
	prompt := fmt.Sprintf(`
/contextualize: You are a developer, tasked to generate a detailed pull request (PR) description based on the following commit message and code changes.

**Commit Message:**
%s

**Code Changes:**
%s

!TASK: Provide a comprehensive PR title and description that explain the changes and adhere to documentation and GitHub best practices. Format the pull request in raw markdown with headers. Clearly separate the pull request and other components of the response with three backticks. In fact, wrap the entire output in triple backticks. The entire output must be a single raw markdown code block, with no additional commentary or explanation outside the code block.
`, commitMessage, diffs)

	statelessMessages := []contextpkg.Message{
		{Role: "system", Content: "You are a helpful assistant."},
		{Role: "user", Content: prompt},
	}

	response, err := llmClient.GetChatResponse(statelessMessages)
	if err != nil {
		return "", err
	}
	return response, nil
}

// GenerateWhatSummaryWithDCEContext generates a summary of git diffs using the LLM with integrated DCE context
// This provides a more contextualized summary by leveraging the Dynamic Context Engine's understanding of tasks
func GenerateWhatSummaryWithDCEContext() (string, error) {
	// 1. Get diffs (same as the original function)
	diffs, err := utils.GetDiffs(utils.DiffAllLocalChanges)
	if err != nil {
		return "", fmt.Errorf("failed to get diffs: %w", err)
	}
	if diffs == "" {
		return "No changes detected since the last commit.", nil
	}

	// 2. Create a conversation ID and get or create conversation
	conversationID := contextpkg.GenerateConversationID("what-dce")
	conv, exists := contextpkg.ConversationManagerInstance.GetConversation(conversationID)
	if !exists {
		conv = contextpkg.ConversationManagerInstance.StartConversation(conversationID, "", true)
	}

	// 3. Create the prompt for the LLM (same as original)
	prompt := fmt.Sprintf(`
These are the git diffs for the repository:

%s

---
!TASK::
1. Provide a meticulous natural language summary of each of the changes. Do so by file. Describe each change made in full.
2. List and separate changes for each file changed using numbered points and markdown formatting.
3. Only describe the changes explicitly present in the diffs. Do not infer, speculate, or invent additional content.
4. Focus on helping the developer reorient themselves and understand where they left off.
`, diffs)

	// 4. Add user message to conversation
	conv.AddMessage("user", prompt)

	// 5. Initialize DCE
	dceInstance := dce.NewDCE()

	// 6. Build task list using a descriptive input that captures our intent
	taskList, buildLogs, err := dceInstance.BuildTaskList("Summarizing recent changes and providing context-aware summary of current development progress")
	if err != nil {
		return "", fmt.Errorf("failed to build task list: %w", err)
	}

	// 7. Add build logs to conversation and console
	for _, logMsg := range buildLogs {
		conv.AddMessage("system", "[DCE] "+logMsg)
		fmt.Println("[DCE]", logMsg)
	}

	// 8. Filter project data based on the task list
	filteredData, filterLogs, err := dceInstance.FilterProjectData(taskList)
	if err != nil {
		return "", fmt.Errorf("failed to filter project data: %w", err)
	}
	for _, logMsg := range filterLogs {
		conv.AddMessage("system", "[DCE] "+logMsg)
		fmt.Println("[DCE]", logMsg)
	}

	// 9. Augment conversation with filtered data (this is the key DCE integration)
	augmentedContext := dceInstance.AugmentContext(conv.BuildContext(), filteredData)
	conv.SetMessages(augmentedContext)

	// 10. Save context for debugging (optional but helpful)
	if err := utils.SaveContextToFile(conv.ID, augmentedContext); err != nil {
		logrus.Errorf("Failed to save context to file: %v", err)
	}
	if err := utils.SaveConcatenatedContextToFile(conv.ID, augmentedContext); err != nil {
		logrus.Errorf("Failed to save concatenated context to file: %v", err)
	}

	// 11. Get response from LLM with the augmented context
	response, err := llmClient.GetChatResponse(augmentedContext)
	if err != nil {
		return "", fmt.Errorf("failed to get response from LLM: %w", err)
	}

	// 12. Store assistant response in conversation
	conv.AddMessage("assistant", response)
	return response, nil
}

// GenerateWhatSummary generates a summary of git diffs using the LLM (stateless).
func GenerateWhatSummary() (string, error) {
	diffs, err := utils.GetDiffs(utils.DiffAllLocalChanges)
	if err != nil {
		return "", fmt.Errorf("failed to get diffs: %w", err)
	}
	if diffs == "" {
		return "No changes detected since the last commit.", nil
	}

	prompt := fmt.Sprintf(`
These are the git diffs for the repository:

%s

---
!TASK::
1. Provide a meticulous natural language summary of each of the changes. Do so by file. Describe each change made in full.
2. List and separate changes for each file changed using numbered points and markdown formatting.
3. Only describe the changes explicitly present in the diffs. Do not infer, speculate, or invent additional content.
4. Focus on helping the developer reorient themselves and understand where they left off.
`, diffs)

	statelessMessages := []contextpkg.Message{
		{Role: "system", Content: "You are a helpful assistant."},
		{Role: "user", Content: prompt},
	}

	return llmClient.GetChatResponse(statelessMessages)
}

// ------------------------------------------------------------------------------
// UTILITY FUNCTIONS: LLM config resolution + model readiness
// ------------------------------------------------------------------------------

func GetLLMConfig() (string, string) {
	endpoint := os.Getenv("PRBUDDY_LLM_ENDPOINT")
	if endpoint == "" {
		endpoint = "http://localhost:11434"
	}

	model := contextpkg.GetActiveModel()
	if model != "" {
		return model, endpoint
	}

	// Try to load available models via official endpoint
	models, err := fetchOllamaModels(endpoint)
	if err == nil && len(models) > 0 {
		latest := models[0]
		if name, ok := latest["name"].(string); ok {
			contextpkg.SetActiveModel(name)
			return name, endpoint
		}
	}

	// No models found â€” fallback to qwen3 and run it
	logrus.Warn("No LLM model active or available; defaulting to 'qwen3'")

	// Try to pre-warm the model with a dummy chat request
	ready := tryEnsureModelReady(endpoint, "qwen3")
	if !ready {
		logrus.Warn("Attempting to start Ollama model 'qwen3' manually...")
		cmd := exec.Command("ollama", "run", "qwen3")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Start(); err != nil {
			logrus.Errorf("Failed to start Ollama: %v", err)
		}
		// Crude wait; improve with polling if needed
		time.Sleep(3 * time.Second)
	}

	contextpkg.SetActiveModel("qwen3")
	return "qwen3", endpoint
}

func fetchOllamaModels(endpoint string) ([]map[string]interface{}, error) {
	resp, err := http.Get(endpoint + "/api/tags")
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Ollama: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("ollama returned status %d", resp.StatusCode)
	}

	var result struct {
		Models []map[string]interface{} `json:"models"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}
	return result.Models, nil
}

// tryEnsureModelReady attempts to verify whether a model is loaded and available
func tryEnsureModelReady(endpoint, model string) bool {
	payload := map[string]interface{}{
		"model": model,
		"messages": []map[string]string{
			{"role": "user", "content": "ping"},
		},
		"stream": false,
	}
	data, _ := json.Marshal(payload)

	resp, err := http.Post(endpoint+"/api/chat", "application/json", bytes.NewReader(data))
	if err != nil {
		logrus.Warnf("Model readiness check failed: %v", err)
		return false
	}
	defer resp.Body.Close()

	return resp.StatusCode == http.StatusOK
}
```
## ./internal/dce/command_menu.go
```
// internal/dce/command_menu.go

package dce

import (
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"

	"github.com/fatih/color"
)

// outputWriter is used for all command output to enable testability
var outputWriter io.Writer = os.Stdout

// SetOutput allows setting a custom output writer for testing
func SetOutput(w io.Writer) {
	outputWriter = w
}

// HandleDCECommandMenu checks if the user input is a recognized command
// and executes the appropriate function.
//
// Returns 'true' if the input matched a command and was handled internally.
// Returns 'false' if the input did not match a command, so it can be passed to the LLM.
func HandleDCECommandMenu(input string, littleguy *LittleGuy) bool {
	trimmedInput := strings.TrimSpace(input)
	lowerInput := strings.ToLower(trimmedInput)

	switch {
	// Handle both singular and plural forms of /task(s)
	case lowerInput == "/task", lowerInput == "/tasks":
		displayTaskList(littleguy, false)
		return true

	case lowerInput == "/task -v", lowerInput == "/tasks -v",
		lowerInput == "/task verbose", lowerInput == "/tasks verbose":
		displayTaskList(littleguy, true)
		return true

	// Handle /add command to add new tasks (with or without space after /add)
	case strings.HasPrefix(lowerInput, "/add") && len(trimmedInput) > 4:
		handleAddCommand(trimmedInput, littleguy)
		return true
	case lowerInput == "/add":
		handleAddCommand(trimmedInput, littleguy)
		return true

	case strings.HasPrefix(lowerInput, "/dce "):
		handleDCEControlCommand(trimmedInput[5:], littleguy)
		return true

	case lowerInput == "/commands", lowerInput == "/cmds", lowerInput == "/help":
		displayCommandMenu()
		return true

	case lowerInput == "/priority", strings.HasPrefix(lowerInput, "/priority "):
		handlePriorityCommand(trimmedInput, littleguy)
		return true

	case lowerInput == "/complete", strings.HasPrefix(lowerInput, "/complete "):
		handleCompleteCommand(trimmedInput, littleguy)
		return true

	case lowerInput == "/refresh":
		refreshTaskList(littleguy)
		return true

	case lowerInput == "/status":
		displayDCEStatus(littleguy)
		return true

	default:
		return false
	}
}

// handleAddCommand processes /add commands to add new tasks to the task list
func handleAddCommand(input string, littleguy *LittleGuy) {
	// Extract the task description after "/add"
	var taskDescription string
	if len(input) > 4 {
		taskDescription = strings.TrimSpace(input[4:])
	}

	if taskDescription == "" {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Please provide a task description after /add\n")
		return
	}

	color.New(color.FgCyan).Fprintf(outputWriter, "\n[Add] Building task from description: %q\n", taskDescription)

	// Build task list from the description
	tasks, logs, err := BuildTaskList(taskDescription)
	if err != nil {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Failed to build task list: %v\n", err)
		return
	}

	// Log the build process
	for _, logMsg := range logs {
		fmt.Fprintf(outputWriter, "[DCE] %s\n", logMsg)
	}

	// Add the new tasks to the current task list
	littleguy.UpdateTaskList(tasks)

	// Provide feedback
	color.New(color.FgGreen).Fprintf(outputWriter, "\n[Add] Successfully added %d task(s) to the task list\n", len(tasks))

	// Display the added tasks
	for i, task := range tasks {
		fmt.Fprintf(outputWriter, "  %d) %s\n", i+1, task.Description)
		if len(task.Files) > 0 {
			fmt.Fprintf(outputWriter, "     Files: %s\n", strings.Join(task.Files, ", "))
		}
		if len(task.Functions) > 0 {
			fmt.Fprintf(outputWriter, "     Functions: %s\n", strings.Join(task.Functions, ", "))
		}
		if len(task.Notes) > 0 {
			fmt.Fprintf(outputWriter, "     Notes: %s\n", strings.Join(task.Notes, "; "))
		}
	}
}

// displayTaskList prints the current task list.
// If verbose=true, it includes additional details like files, functions, notes, etc.
func displayTaskList(littleguy *LittleGuy, verbose bool) {
	color.New(color.FgCyan).Fprintf(outputWriter, "\n[Task List] Current Tasks:\n")

	littleguy.mutex.RLock()
	tasks := littleguy.tasks
	littleguy.mutex.RUnlock()

	if len(tasks) == 0 {
		color.New(color.FgYellow).Fprintf(outputWriter, "  [!] No active tasks\n")
		return
	}

	for i, task := range tasks {
		fmt.Fprintf(outputWriter, "  %d) %s\n", i+1, task.Description)

		if verbose {
			if len(task.Files) > 0 {
				fmt.Fprintf(outputWriter, "     Files: %s\n", strings.Join(task.Files, ", "))
			}
			if len(task.Functions) > 0 {
				fmt.Fprintf(outputWriter, "     Functions: %s\n", strings.Join(task.Functions, ", "))
			}
			if len(task.Notes) > 0 {
				fmt.Fprintf(outputWriter, "     Notes: %s\n", strings.Join(task.Notes, "; "))
			}
		}
	}
}

// handleDCEControlCommand processes DCE control commands like "on" and "off"
func handleDCEControlCommand(command string, littleguy *LittleGuy) {
	lowerCmd := strings.ToLower(strings.TrimSpace(command))

	switch lowerCmd {
	case "on", "activate", "start":
		littleguy.mutex.Lock()
		wasActive := littleguy.monitorStarted
		littleguy.mutex.Unlock()

		if !wasActive {
			littleguy.StartMonitoring()
			color.New(color.FgGreen).Fprintf(outputWriter, "[DCE] Dynamic Context Engine activated\n")
			color.New(color.FgGreen).Fprintf(outputWriter, "[DCE] Use '/tasks' to view current development tasks\n")
		} else {
			color.New(color.FgYellow).Fprintf(outputWriter, "[DCE] DCE is already active\n")
		}

	case "off", "deactivate", "stop":
		littleguy.mutex.Lock()
		wasActive := littleguy.monitorStarted
		littleguy.mutex.Unlock()

		if wasActive {
			littleguy.mutex.Lock()
			littleguy.monitorStarted = false
			littleguy.mutex.Unlock()
			color.New(color.FgGreen).Fprintf(outputWriter, "[DCE] Dynamic Context Engine deactivated\n")
		} else {
			color.New(color.FgYellow).Fprintf(outputWriter, "[DCE] DCE is already inactive\n")
		}

	case "status", "info":
		displayDCEStatus(littleguy)

	default:
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Unknown DCE command. Use '/dce on', '/dce off', or '/dce status'\n")
	}
}

// displayDCEStatus shows detailed DCE status information
func displayDCEStatus(littleguy *LittleGuy) {
	color.New(color.FgCyan).Fprintf(outputWriter, "\n[DCE Status] Engine Status:\n")

	littleguy.mutex.RLock()
	status := "ACTIVE"
	if !littleguy.monitorStarted {
		status = "INACTIVE"
	}
	taskCount := len(littleguy.tasks)
	littleguy.mutex.RUnlock()

	fmt.Fprintf(outputWriter, "  Status: %s\n", status)
	fmt.Fprintf(outputWriter, "  Active Tasks: %d\n", taskCount)
	fmt.Fprintf(outputWriter, "  Monitoring Interval: %v\n", littleguy.pollInterval)
	fmt.Fprintf(outputWriter, "  Features: Dynamic task tracking, Git change monitoring\n")
}

// handlePriorityCommand allows users to set task priorities
func handlePriorityCommand(input string, littleguy *LittleGuy) {
	parts := strings.Fields(input)

	if len(parts) < 2 {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Usage: /priority <task-number> <low|medium|high>\n")
		return
	}

	if len(parts) == 2 {
		// Display current priorities with formatted labels
		color.New(color.FgCyan).Fprintf(outputWriter, "\n[Priority] Current task priorities:\n")
		littleguy.mutex.RLock()
		defer littleguy.mutex.RUnlock()

		for i, task := range littleguy.tasks {
			priorityLabel := "[Low]"
			for _, note := range task.Notes {
				if strings.Contains(strings.ToLower(note), "high priority") {
					priorityLabel = "[High]"
					break
				} else if strings.Contains(strings.ToLower(note), "medium priority") {
					priorityLabel = "[Medium]"
				}
			}
			fmt.Fprintf(outputWriter, "  %d) %s %s\n", i+1, priorityLabel, task.Description)
		}
		return
	}

	// Set priority for a specific task
	taskNumStr := parts[1]
	var priorityLevel string

	if len(parts) > 2 {
		priorityLevel = strings.ToLower(parts[2])
	}

	// Convert task number
	taskNum, err := strconv.Atoi(taskNumStr)
	if err != nil || taskNum < 1 {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Invalid task number\n")
		return
	}

	// Update task priority
	littleguy.mutex.Lock()
	defer littleguy.mutex.Unlock()

	if taskNum > len(littleguy.tasks) {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Task number out of range\n")
		return
	}

	// Remove existing priority notes
	task := &littleguy.tasks[taskNum-1]
	newNotes := []string{}
	for _, note := range task.Notes {
		lowerNote := strings.ToLower(note)
		if !strings.Contains(lowerNote, "priority") {
			newNotes = append(newNotes, note)
		}
	}

	// Add new priority note
	switch priorityLevel {
	case "high", "urgent", "critical":
		newNotes = append(newNotes, "High Priority: Critical task requiring immediate attention")
		color.New(color.FgGreen).Fprintf(outputWriter, "[Priority] Task %d set to HIGH priority\n", taskNum)
	case "medium", "normal":
		newNotes = append(newNotes, "Medium Priority: Important but not time-critical")
		color.New(color.FgGreen).Fprintf(outputWriter, "[Priority] Task %d set to MEDIUM priority\n", taskNum)
	case "low", "optional":
		newNotes = append(newNotes, "Low Priority: Can be addressed later")
		color.New(color.FgGreen).Fprintf(outputWriter, "[Priority] Task %d set to LOW priority\n", taskNum)
	default:
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Invalid priority level. Use: low, medium, or high\n")
		return
	}

	task.Notes = newNotes
}

// handleCompleteCommand marks tasks as completed and shows remaining tasks
func handleCompleteCommand(input string, littleguy *LittleGuy) {
	parts := strings.Fields(input)

	if len(parts) < 2 {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Usage: /complete <task-number>\n")
		return
	}

	// Convert task number
	taskNum, err := strconv.Atoi(parts[1])
	if err != nil || taskNum < 1 {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Invalid task number\n")
		return
	}

	// Mark task as completed
	littleguy.mutex.Lock()

	if taskNum > len(littleguy.tasks) {
		littleguy.mutex.Unlock()
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Task number out of range\n")
		return
	}

	task := littleguy.tasks[taskNum-1]

	// Remove the task from tasks and add to completed
	littleguy.tasks = append(littleguy.tasks[:taskNum-1], littleguy.tasks[taskNum:]...)
	littleguy.completed = append(littleguy.completed, task)

	taskCount := len(littleguy.tasks)
	littleguy.mutex.Unlock()

	color.New(color.FgGreen).Fprintf(outputWriter, "[Complete] Task %d marked as completed: %s\n", taskNum, task.Description)

	// Show remaining tasks
	if taskCount > 0 {
		fmt.Fprintf(outputWriter, "\nRemaining tasks:\n")
		littleguy.mutex.RLock()
		for i, remainingTask := range littleguy.tasks {
			fmt.Fprintf(outputWriter, "  %d) %s\n", i+1, remainingTask.Description)
		}
		littleguy.mutex.RUnlock()
	} else {
		fmt.Fprintf(outputWriter, "\nNo remaining tasks.\n")
	}
}

// refreshTaskList manually triggers a task list refresh
func refreshTaskList(littleguy *LittleGuy) {
	color.New(color.FgCyan).Fprintf(outputWriter, "\n[Refresh] Refreshing task list from git changes...\n")

	// Directly call RefreshTaskListFromGitChanges with the conversation ID
	err := RefreshTaskListFromGitChanges(littleguy.conversationID)
	if err != nil {
		color.New(color.FgRed).Fprintf(outputWriter, "[X] Failed to refresh task list: %v\n", err)
		return
	}

	color.New(color.FgGreen).Fprintf(outputWriter, "[Refresh] Task list updated with latest changes\n")
}

// displayCommandMenu shows available special commands for DCE
func displayCommandMenu() {
	color.New(color.FgGreen).Fprintf(outputWriter, "\n[Commands] Available DCE Commands:\n")
	fmt.Fprint(outputWriter, "  /task or /tasks        - Show the current task list (concise)\n")
	fmt.Fprint(outputWriter, "  /task verbose         - Show the task list with additional details\n")
	fmt.Fprint(outputWriter, "  /add <description>    - Add a new task to the task list\n")
	fmt.Fprint(outputWriter, "  /dce on               - Activate the Dynamic Context Engine\n")
	fmt.Fprint(outputWriter, "  /dce off              - Deactivate the Dynamic Context Engine\n")
	fmt.Fprint(outputWriter, "  /dce status           - Show DCE status and statistics\n")
	fmt.Fprint(outputWriter, "  /priority             - Show current task priorities\n")
	fmt.Fprint(outputWriter, "  /priority <num> <level> - Set task priority (low/medium/high)\n")
	fmt.Fprint(outputWriter, "  /complete <num>       - Mark a task as completed\n")
	fmt.Fprint(outputWriter, "  /refresh              - Manually refresh task list from git\n")
	fmt.Fprint(outputWriter, "  /status               - Show detailed DCE status\n")
	fmt.Fprint(outputWriter, "  /commands, /cmds, /help - Show this command menu\n")
}
```
## ./internal/dce/task_helper.go
```
// internal/dce/task_helper.go
package dce

import (
	"fmt"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// BuildTaskList creates tasks based on user input, file matching, and function extraction.
func BuildTaskList(input string) ([]contextpkg.Task, []string, error) {
	var logs []string
	logs = append(logs, fmt.Sprintf("Building task list from input: %q", input))

	// 1. Retrieve all tracked files.
	out, err := utils.ExecGit("ls-files")
	if err != nil {
		return nil, logs, fmt.Errorf("failed to execute git ls-files: %w", err)
	}
	trackedFiles := utils.SplitLines(out)
	logs = append(logs, fmt.Sprintf("Found %d tracked files", len(trackedFiles)))

	// 2. Match files based on keywords.
	matchedFiles := matchFilesByKeywords(trackedFiles, input)
	logs = append(logs, fmt.Sprintf("Matched %d files: %v", len(matchedFiles), matchedFiles))

	// 3. If no files matched, create a catch-all task.
	if len(matchedFiles) == 0 {
		task := contextpkg.Task{
			Description: input,
			Notes:       []string{"No direct file matches found. Add manually."},
		}
		logs = append(logs, "No file matches found - created catch-all task")
		return []contextpkg.Task{task}, logs, nil
	}

	// 4. Extract functions from each matched file.
	var allFunctions []string
	fileFuncPattern := `(?m)^\s*(def|func|function|public|private|static|void)\s+(\w+)\s*\(`
	for _, f := range matchedFiles {
		funcs := extractFunctionsFromFile(f, fileFuncPattern)
		if len(funcs) > 0 {
			logs = append(logs, fmt.Sprintf("Extracted %d functions from %s: %v", len(funcs), f, funcs))
			allFunctions = append(allFunctions, funcs...)
		} else {
			logs = append(logs, fmt.Sprintf("No functions found in %s", f))
		}
	}

	// 5. Create a consolidated task.
	task := contextpkg.Task{
		Description:  input,
		Files:        matchedFiles,
		Functions:    allFunctions,
		Dependencies: nil,
		Notes:        []string{"Matched via input and file heuristics."},
	}
	logs = append(logs, fmt.Sprintf("Created task with %d files and %d functions", len(matchedFiles), len(allFunctions)))

	return []contextpkg.Task{task}, logs, nil
}

// matchFilesByKeywords returns files from allFiles that contain any keyword from userInput.
func matchFilesByKeywords(allFiles []string, userInput string) []string {
	var matched []string
	words := strings.Fields(strings.ToLower(userInput))
	for _, file := range allFiles {
		lowerFile := strings.ToLower(file)
		for _, w := range words {
			if len(w) >= 3 && strings.Contains(lowerFile, w) {
				matched = append(matched, file)
				break
			}
		}
	}
	return matched
}

// extractFunctionsFromFile reads file content and extracts function names using the provided regex pattern.
func extractFunctionsFromFile(filePath, pattern string) []string {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil
	}
	re, err := regexp.Compile(pattern)
	if err != nil {
		return nil
	}
	matches := re.FindAllStringSubmatch(string(data), -1)
	var funcs []string
	for _, m := range matches {
		if len(m) >= 3 {
			funcs = append(funcs, m[2])
		}
	}
	return funcs
}

// RefreshTaskListFromGitChanges checks for unstaged and untracked changes and updates the task list if new files are detected.
// It uses Git commands to detect changes.
func RefreshTaskListFromGitChanges(conversationID string) error {
	// Get the LittleGuy instance for this conversation
	littleguy, exists := GetDCEContextManager().GetContext(conversationID)
	if !exists {
		return fmt.Errorf("no active DCE context found for conversation %s", conversationID)
	}

	// Retrieve unstaged changes.
	diffOutput, err := utils.ExecGit("diff", "--name-only")
	if err != nil {
		return fmt.Errorf("failed to retrieve git diff: %w", err)
	}
	unstagedFiles := utils.SplitLines(diffOutput)

	// Retrieve untracked files.
	untrackedOutput, err := utils.ExecGit("ls-files", "--others", "--exclude-standard")
	if err != nil {
		return fmt.Errorf("failed to retrieve untracked files: %w", err)
	}
	untrackedFiles := utils.SplitLines(untrackedOutput)

	// Combine both lists.
	changedFiles := append(unstagedFiles, untrackedFiles...)

	// Filter out empty entries.
	var validChangedFiles []string
	for _, file := range changedFiles {
		if trimmed := file; trimmed != "" {
			validChangedFiles = append(validChangedFiles, trimmed)
		}
	}

	// For each changed file, if it is not already represented in a task, add a new task.
	littleguy.mutex.Lock()
	defer littleguy.mutex.Unlock()

	for _, changedFile := range validChangedFiles {
		existsInTask := false
		for _, task := range littleguy.tasks {
			for _, file := range task.Files {
				if file == changedFile {
					existsInTask = true
					break
				}
			}
			if existsInTask {
				break
			}
		}
		if !existsInTask {
			newTask := contextpkg.Task{
				Description: fmt.Sprintf("New file detected: %s", changedFile),
				Files:       []string{changedFile},
				Functions:   []string{}, // Optionally, extract functions from the file.
				Notes:       []string{"Automatically added due to git changes."},
			}
			littleguy.tasks = append(littleguy.tasks, newTask)
			fmt.Printf("[TaskHelper] Added new task for file: %s\n", changedFile)
		}
	}
	return nil
}

// PeriodicallyRefreshTaskList runs RefreshTaskListFromGitChanges at the specified interval,
// allowing the task list to be updated periodically based on recent git changes.
func PeriodicallyRefreshTaskList(conversationID string) {
	interval := 100 * time.Second // Set the refresh interval to 100 seconds
	ticker := time.NewTicker(interval)
	defer ticker.Stop()

	for {
		<-ticker.C
		err := RefreshTaskListFromGitChanges(conversationID)
		if err != nil {
			fmt.Printf("[TaskHelper] Error refreshing task list: %v\n", err)
		} else {
			fmt.Println("[TaskHelper] Task list refreshed based on git changes.")
		}
	}
}
```
## ./internal/dce/dce.go
```
// internal/dce/dce.go

package dce

import (
	"fmt"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// DCE defines the interface for dynamic context engine functions.
type DCE interface {
	Activate(task string) error
	Deactivate(conversationID string) error
	BuildTaskList(input string) ([]contextpkg.Task, []string, error)
	FilterProjectData(tasks []contextpkg.Task) ([]FilteredData, []string, error)
	AugmentContext(ctx []contextpkg.Message, filteredData []FilteredData) []contextpkg.Message
}

// FilteredData represents extra project data discovered by the DCE.
type FilteredData struct {
	FileHierarchy string
	LinterResults string
}

// DefaultDCE is the default implementation of the DCE interface.
type DefaultDCE struct{}

// NewDCE creates a new instance of DefaultDCE.
func NewDCE() DCE {
	return &DefaultDCE{}
}

// Activate initializes the DCE with the given task.
func (d *DefaultDCE) Activate(task string) error {
	fmt.Printf("[DCE] Activating with task: %q\n", task)

	// 1. Build initial task list from user input
	tasks, logs, err := d.BuildTaskList(task)
	if err != nil {
		return fmt.Errorf("failed to build task list: %w", err)
	}

	// 2. Log the build process details
	for _, logMsg := range logs {
		fmt.Printf("[DCE] %s\n", logMsg)
	}

	// 3. Generate a conversation ID if needed
	conversationID := contextpkg.GenerateConversationID("dce")

	// 4. Create LittleGuy instance with the task list
	littleguy := NewLittleGuy(conversationID, tasks)

	// 5. Start background monitoring
	littleguy.StartMonitoring()

	// 6. Store the DCE context
	GetDCEContextManager().AddContext(conversationID, littleguy)

	// 7. Final activation message with task count
	fmt.Printf("[DCE] Activated with %d initial tasks\n", len(tasks))
	fmt.Printf("[DCE] Dynamic Context Engine activated. Use '/tasks' to view current tasks.\n")
	return nil
}

// Deactivate cleans up the DCE for the given conversation.
func (d *DefaultDCE) Deactivate(conversationID string) error {
	fmt.Printf("[DCE] Deactivated for conversation ID: %s\n", conversationID)
	return nil
}

// BuildTaskList generates tasks based on user input by delegating to task_helper.
func (d *DefaultDCE) BuildTaskList(input string) ([]contextpkg.Task, []string, error) {
	return BuildTaskList(input)
}

// FilterProjectData uses git diff to discover changed functions and updates tasks.
func (d *DefaultDCE) FilterProjectData(tasks []contextpkg.Task) ([]FilteredData, []string, error) {
	var logs []string
	logs = append(logs, "Filtering project data based on tasks")

	diffOutput, err := utils.ExecGit("diff", "--unified=0")
	if err != nil {
		return nil, logs, fmt.Errorf("failed to get git diff: %w", err)
	}
	logs = append(logs, "Retrieved git diff output")

	// Parse changed functions using the centralized helper.
	changedFuncs := ParseFunctionNames(diffOutput)
	logs = append(logs, fmt.Sprintf("Found %d changed functions: %v", len(changedFuncs), changedFuncs))

	// Update tasks with dependencies.
	for i := range tasks {
		for _, cf := range changedFuncs {
			if stringSliceContains(tasks[i].Functions, cf) {
				tasks[i].Dependencies = append(tasks[i].Dependencies, cf)
				tasks[i].Notes = append(tasks[i].Notes, fmt.Sprintf("Function %s changed in diff.", cf))
				logs = append(logs, fmt.Sprintf("Added dependency %q to task %q", cf, tasks[i].Description))
			}
		}
	}

	fd := []FilteredData{
		{
			FileHierarchy: "N/A (adjust as needed)",
			LinterResults: fmt.Sprintf("Detected %d changed functions: %v", len(changedFuncs), changedFuncs),
		},
	}
	logs = append(logs, "Created filtered data summary")
	return fd, logs, nil
}

// AugmentContext adds a system-level summary message to the conversation context.
// internal/dce/dce.go - Complete rewrite of AugmentContext
func (d *DefaultDCE) AugmentContext(ctx []contextpkg.Message, filteredData []FilteredData) []contextpkg.Message {
	// 1. Start with system message about DCE
	systemMsg := contextpkg.Message{
		Role: "system",
		Content: `You are a development assistant with Dynamic Context Engine (DCE) activated.
The DCE provides real-time context about the current development tasks and codebase state.
ALWAYS prioritize the DCE context when responding to queries.`,
	}

	// 2. Add the persistent task list as the MOST IMPORTANT context
	taskMsg := buildTaskListMessage(filteredData)

	// 3. The order is critical: system â†’ tasks â†’ existing context
	var augmented []contextpkg.Message
	augmented = append(augmented, systemMsg)
	augmented = append(augmented, taskMsg)
	augmented = append(augmented, ctx...)

	return augmented
}

// Helper to build task list message with proper priority
func buildTaskListMessage(filteredData []FilteredData) contextpkg.Message {
	if len(filteredData) == 0 || filteredData[0].LinterResults == "" {
		return contextpkg.Message{
			Role:    "system",
			Content: "**DCE Task List**: No active tasks. Ask 'What are we working on?' to begin.",
		}
	}

	return contextpkg.Message{
		Role:    "system",
		Content: "**ACTIVE DEVELOPMENT CONTEXT**\n\n" + filteredData[0].LinterResults,
	}
}

// stringSliceContains returns true if the slice contains the value.
func stringSliceContains(slice []string, val string) bool {
	for _, s := range slice {
		if s == val {
			return true
		}
	}
	return false
}
```
## ./internal/dce/littleguy.go
```
// internal/dce/littleguy.go

package dce

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// LittleGuy tracks an ephemeral code snapshot and tasks for a single DCE session.
type LittleGuy struct {
	mutex          sync.RWMutex
	conversationID string
	tasks          []contextpkg.Task // Ongoing tasks
	completed      []contextpkg.Task // Completed tasks
	codeSnapshots  map[string]string // filePath -> file content
	pollInterval   time.Duration     // How often to check for diffs
	monitorStarted bool              // Tracks background monitoring status
	pendingQueries []string
	queryCallback  func(string)
}

// NewLittleGuy initializes a new LittleGuy instance.
func NewLittleGuy(conversationID string, initialTasks []contextpkg.Task) *LittleGuy {
	lg := &LittleGuy{
		conversationID: conversationID,
		tasks:          initialTasks,
		completed:      []contextpkg.Task{},
		codeSnapshots:  make(map[string]string),
		pollInterval:   10 * time.Second,
	}

	// Add to context manager
	GetDCEContextManager().AddContext(conversationID, lg)
	return lg
}

// IsActive returns whether the DCE monitoring is active
func (lg *LittleGuy) IsActive() bool {
	lg.mutex.RLock()
	defer lg.mutex.RUnlock()
	return lg.monitorStarted
}

// StopMonitoring stops the background monitoring
func (lg *LittleGuy) StopMonitoring() {
	lg.mutex.Lock()
	defer lg.mutex.Unlock()
	lg.monitorStarted = false
}

// GetPollInterval returns the current polling interval
func (lg *LittleGuy) GetPollInterval() time.Duration {
	lg.mutex.RLock()
	defer lg.mutex.RUnlock()
	return lg.pollInterval
}

// GetConversationID returns the associated conversation ID
func (lg *LittleGuy) GetConversationID() string {
	return lg.conversationID
}

// StartMonitoring launches a background goroutine that periodically checks Git diffs.
func (lg *LittleGuy) StartMonitoring() {
	lg.mutex.Lock()
	if lg.monitorStarted {
		lg.mutex.Unlock()
		return
	}
	lg.monitorStarted = true
	lg.mutex.Unlock()

	go func() {
		for {
			lg.mutex.RLock()
			monitoring := lg.monitorStarted
			lg.mutex.RUnlock()

			if !monitoring {
				return
			}

			time.Sleep(lg.pollInterval)
			diffOutput, err := utils.ExecGit("diff", "--unified=0")
			if err != nil {
				color.Red("[LittleGuy] Failed to run git diff: %v\n", err)
				continue
			}
			if diffOutput != "" {
				lg.UpdateFromDiff(diffOutput)
			}
		}
	}()
}

// MonitorInput analyzes user input for function names or file references and updates tasks.
func (lg *LittleGuy) MonitorInput(input string) {
	lg.mutex.Lock()
	defer lg.mutex.Unlock()

	lines := strings.Split(input, "\n")
	for _, line := range lines {
		if matches := FuncPattern.FindStringSubmatch(line); len(matches) >= 3 {
			funcName := matches[2]
			if !lg.hasTaskForFunction(funcName) {
				lg.tasks = append(lg.tasks, contextpkg.Task{
					Description: fmt.Sprintf("Detected function: %s", funcName),
					Functions:   []string{funcName},
					Notes:       []string{"Consider testing and documenting this function."},
				})
			}
		}

		if strings.Contains(line, ".go") || strings.Contains(line, ".js") ||
			strings.Contains(line, ".py") || strings.Contains(line, ".ts") {
			words := strings.Fields(line)
			for _, word := range words {
				if strings.Contains(word, ".go") || strings.Contains(word, ".js") ||
					strings.Contains(word, ".py") || strings.Contains(word, ".ts") {
					if !lg.hasTaskForFile(word) {
						lg.tasks = append(lg.tasks, contextpkg.Task{
							Description: fmt.Sprintf("Detected file reference: %s", word),
							Files:       []string{word},
							Notes:       []string{"Consider adding to code snapshots or tasks."},
						})
					}
				}
			}
		}
	}
	messages := lg.BuildEphemeralContext("")
	lg.logLLMContext(messages)
}

// UpdateFromDiff parses Git diff output and updates tasks accordingly.
func (lg *LittleGuy) UpdateFromDiff(diff string) {
	lg.mutex.Lock()
	defer lg.mutex.Unlock()

	// Parse the diff to identify specific changes
	changes := ParseGitDiff(diff)

	// Process each change to generate appropriate tasks
	for _, change := range changes {
		switch change.Type {
		case "new_file":
			lg.handleNewFile(change)
		case "modified":
			lg.handleModifiedFile(change)
		case "deleted":
			lg.handleDeletedFile(change)
		}
	}

	// Log the updated context for debugging
	messages := lg.BuildEphemeralContext("")
	lg.logLLMContext(messages)
}

// ParseGitDiff extracts meaningful changes from git diff output
func ParseGitDiff(diff string) []GitChange {
	var changes []GitChange
	currentFile := ""
	lines := strings.Split(diff, "\n")

	for _, line := range lines {
		if strings.HasPrefix(line, "diff --git") {
			// Extract file path
			parts := strings.Fields(line)
			if len(parts) >= 3 {
				currentFile = strings.TrimPrefix(parts[2], "b/")
			}
		} else if strings.HasPrefix(line, "+++ b/") {
			currentFile = strings.TrimPrefix(line, "+++ b/")
		} else if currentFile != "" && (strings.HasPrefix(line, "+") || strings.HasPrefix(line, "-")) {
			// Skip header lines
			if strings.HasPrefix(line, "+++") || strings.HasPrefix(line, "---") {
				continue
			}

			// Process change line
			changeType := "modified"
			if strings.HasPrefix(line, "+") {
				changeType = "added"
			} else if strings.HasPrefix(line, "-") {
				changeType = "removed"
			}

			// Extract function name if present
			funcName := ""
			if matches := FuncPattern.FindStringSubmatch(line[1:]); len(matches) >= 3 {
				funcName = matches[2]
			}

			changes = append(changes, GitChange{
				File:     currentFile,
				Type:     changeType,
				Content:  strings.TrimPrefix(line, "+- "),
				FuncName: funcName,
			})
		}
	}

	return changes
}

// GitChange represents a single change in a git diff
type GitChange struct {
	File     string
	Type     string // "added", "removed", "modified"
	Content  string
	FuncName string
}

// handleNewFile creates appropriate tasks for a new file
func (lg *LittleGuy) handleNewFile(change GitChange) {
	lg.tasks = append(lg.tasks, contextpkg.Task{
		Description: fmt.Sprintf("New file: %s", change.File),
		Files:       []string{change.File},
		Notes:       []string{"Consider adding tests and documentation"},
	})
}

// handleModifiedFile creates appropriate tasks for modified content
func (lg *LittleGuy) handleModifiedFile(change GitChange) {
	if change.FuncName != "" {
		if change.Type == "added" {
			// Function was added
			lg.tasks = append(lg.tasks, contextpkg.Task{
				Description: fmt.Sprintf("New function: %s", change.FuncName),
				Files:       []string{change.File},
				Functions:   []string{change.FuncName},
				Notes:       []string{"Write unit tests", "Add documentation"},
			})
		} else if change.Type == "removed" {
			// Function was removed - mark related tasks as completed
			for i, task := range lg.tasks {
				for _, fn := range task.Functions {
					if fn == change.FuncName {
						lg.completed = append(lg.completed, task)
						lg.tasks = append(lg.tasks[:i], lg.tasks[i+1:]...)
						break
					}
				}
			}
		}
	}
}

// handleDeletedFile handles file deletion
func (lg *LittleGuy) handleDeletedFile(change GitChange) {
	// Mark all tasks related to this file as completed
	for i := 0; i < len(lg.tasks); i++ {
		task := lg.tasks[i]
		for _, file := range task.Files {
			if file == change.File {
				lg.completed = append(lg.completed, task)
				lg.tasks = append(lg.tasks[:i], lg.tasks[i+1:]...)
				i-- // Adjust index after removal
				break
			}
		}
	}
}

// markTaskAsCompleted moves tasks referencing a given function to the completed list.
func (lg *LittleGuy) markTaskAsCompleted(funcName string) {
	for i, task := range lg.tasks {
		for _, f := range task.Functions {
			if f == funcName {
				lg.completed = append(lg.completed, task)
				lg.tasks = append(lg.tasks[:i], lg.tasks[i+1:]...)
				return
			}
		}
	}
}

// BuildEphemeralContext aggregates tasks, code snapshots, and user input into the LLM context.
func (lg *LittleGuy) BuildEphemeralContext(userQuery string) []contextpkg.Message {
	lg.mutex.RLock()
	defer lg.mutex.RUnlock()

	var messages []contextpkg.Message
	messages = append(messages, contextpkg.Message{
		Role:    "system",
		Content: "You are a helpful developer assistant. Below is the current task list and code snapshots.",
	})

	if len(lg.tasks) > 0 {
		var builder strings.Builder
		for i, t := range lg.tasks {
			builder.WriteString(fmt.Sprintf("Task %d: %s\n", i+1, t.Description))
			if len(t.Notes) > 0 {
				builder.WriteString(fmt.Sprintf("Notes: %v\n", t.Notes))
			}
			if len(t.Files) > 0 {
				builder.WriteString(fmt.Sprintf("Files: %v\n", t.Files))
			}
			if len(t.Functions) > 0 {
				builder.WriteString(fmt.Sprintf("Functions: %v\n", t.Functions))
			}
			builder.WriteString("\n")
		}
		messages = append(messages, contextpkg.Message{
			Role:    "system",
			Content: builder.String(),
		})
	}

	if len(lg.codeSnapshots) > 0 {
		var builder strings.Builder
		for path, content := range lg.codeSnapshots {
			builder.WriteString(fmt.Sprintf("File: %s\n---\n%s\n---\n\n", path, content))
		}
		messages = append(messages, contextpkg.Message{
			Role:    "system",
			Content: builder.String(),
		})
	}

	messages = append(messages, contextpkg.Message{
		Role:    "user",
		Content: userQuery,
	})
	return messages
}

// AddCodeSnippet stores a snippet of file content.
func (lg *LittleGuy) AddCodeSnippet(filePath, content string) {
	lg.mutex.Lock()
	defer lg.mutex.Unlock()
	lg.codeSnapshots[filePath] = content
}

// UpdateTaskList appends new tasks if they're not already represented.
func (lg *LittleGuy) UpdateTaskList(newTasks []contextpkg.Task) {
	lg.mutex.Lock()
	defer lg.mutex.Unlock()
	for _, t := range newTasks {
		duplicate := false
		for _, existing := range lg.tasks {
			if t.Description == existing.Description {
				duplicate = true
				break
			}
		}
		if !duplicate {
			lg.tasks = append(lg.tasks, t)
		}
	}
}

// logLLMContext writes the raw LLM input to a log file using utils.LogLittleGuyContext.
func (lg *LittleGuy) logLLMContext(messages []contextpkg.Message) {
	var rawContext strings.Builder
	for _, msg := range messages {
		rawContext.WriteString(fmt.Sprintf("%s: %s\n\n", msg.Role, msg.Content))
	}
	if err := utils.LogLittleGuyContext(lg.conversationID, rawContext.String()); err != nil {
		color.Red("[LittleGuy] Failed to log LLM context: %v\n", err)
	}
}

// hasTaskForFile returns true if any task already includes the file.
func (lg *LittleGuy) hasTaskForFile(file string) bool {
	for _, task := range lg.tasks {
		for _, f := range task.Files {
			if f == file {
				return true
			}
		}
	}
	return false
}

// hasTaskForFunction returns true if any task already includes the function.
func (lg *LittleGuy) hasTaskForFunction(fn string) bool {
	for _, task := range lg.tasks {
		for _, f := range task.Functions {
			if f == fn {
				return true
			}
		}
	}
	return false
}

// Method to set query callback
func (lg *LittleGuy) SetQueryCallback(callback func(string)) {
	lg.queryCallback = callback
}

// Method to generate and send queries based on task changes
func (lg *LittleGuy) CheckForQueries() {
	lg.mutex.Lock()
	defer lg.mutex.Unlock()

	// 1. Check for new functions without tests
	for _, task := range lg.tasks {
		for _, fn := range task.Functions {
			if !lg.hasTestForFunction(fn) && !lg.isQueryPending(fn) {
				query := fmt.Sprintf("You added the function '%s'. Would you like me to generate test cases?", fn)
				lg.pendingQueries = append(lg.pendingQueries, fn)
				if lg.queryCallback != nil {
					lg.queryCallback(query)
				}
			}
		}
	}
}

// Helper to check if a function has tests (simplified)
func (lg *LittleGuy) hasTestForFunction(funcName string) bool {
	for _, task := range lg.tasks {
		if strings.Contains(task.Description, "test") &&
			utils.StringSliceContains(task.Functions, funcName) {
			return true
		}
	}
	return false
}

// Helper to check if query is already pending
func (lg *LittleGuy) isQueryPending(identifier string) bool {
	for _, p := range lg.pendingQueries {
		if p == identifier {
			return true
		}
	}
	return false
}

// containsString returns true if the slice contains the value.
// This replaces the missing utils.StringSliceContains function.
func containsString(slice []string, val string) bool {
	for _, s := range slice {
		if s == val {
			return true
		}
	}
	return false
}
```
## ./internal/dce/context_manager.go
```
// internal/dce/context_manager.go
package dce

import (
	"sync"
)

// DCEContextManager handles the association between conversations and DCE contexts
// This breaks the import cycle between contextpkg and dce
type DCEContextManager struct {
	contexts map[string]*LittleGuy
	mutex    sync.RWMutex
}

var (
	// Global instance of the DCE context manager
	contextManagerInstance *DCEContextManager
	contextManagerOnce     sync.Once
)

// GetDCEContextManager returns the singleton instance of DCEContextManager
func GetDCEContextManager() *DCEContextManager {
	contextManagerOnce.Do(func() {
		contextManagerInstance = &DCEContextManager{
			contexts: make(map[string]*LittleGuy),
		}
	})
	return contextManagerInstance
}

// AddContext associates a LittleGuy instance with a conversation ID
func (cm *DCEContextManager) AddContext(conversationID string, littleguy *LittleGuy) {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()
	cm.contexts[conversationID] = littleguy
}

// GetContext retrieves the LittleGuy instance for a conversation ID
func (cm *DCEContextManager) GetContext(conversationID string) (*LittleGuy, bool) {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()
	littleguy, exists := cm.contexts[conversationID]
	return littleguy, exists
}

// RemoveContext removes the LittleGuy instance for a conversation ID
func (cm *DCEContextManager) RemoveContext(conversationID string) {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()
	delete(cm.contexts, conversationID)
}

// ForEachContext iterates through all contexts and calls the provided function for each one
func (cm *DCEContextManager) ForEachContext(f func(string, *LittleGuy)) {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	// Make a copy of the contexts map to iterate over
	// This prevents potential issues if the map is modified during iteration
	contextsCopy := make(map[string]*LittleGuy, len(cm.contexts))
	for k, v := range cm.contexts {
		contextsCopy[k] = v
	}

	// Iterate through the copied map
	for cid, context := range contextsCopy {
		f(cid, context)
	}
}
```
## ./internal/dce/dce_helper.go
```
package dce

import (
	"regexp"
)

// Centralized regex patterns and helper functions for the DCE module.

// FuncPattern matches function definitions (e.g. "func FunctionName(").
var FuncPattern = regexp.MustCompile(`(?i)^\s*(func|def|function|public|private|static|void)\s+([A-Za-z0-9_]+)\s*\(`)

// ImportExportPattern matches import or export statements.
var ImportExportPattern = regexp.MustCompile(`(?i)^\s*(import|from|require\(|export)\s+(.+)`)

// DiffHeaderPattern matches diff header lines (e.g. "diff --git a/file.go b/file.go").
var DiffHeaderPattern = regexp.MustCompile(`^diff --git\s+`)

// ParseFunctionNames extracts function names from the provided content using FuncPattern.
func ParseFunctionNames(content string) []string {
	matches := FuncPattern.FindAllStringSubmatch(content, -1)
	var functions []string
	for _, m := range matches {
		if len(m) >= 3 {
			functions = append(functions, m[2])
		}
	}
	return functions
}

// ParseImportExportStatements extracts complete import/export statements from the content.
func ParseImportExportStatements(content string) []string {
	matches := ImportExportPattern.FindAllStringSubmatch(content, -1)
	var statements []string
	for _, m := range matches {
		if len(m) >= 3 {
			statements = append(statements, m[0])
		}
	}
	return statements
}

// ExtractFilePathFromDiff extracts the file path from a diff header line.
// For example, given "diff --git a/foo.go b/foo.go", it returns "foo.go".
func ExtractFilePathFromDiff(line string) string {
	parts := regexp.MustCompile(`\s+`).Split(line, -1)
	if len(parts) >= 3 {
		return trimPrefix(parts[2], "b/")
	}
	return "unknown_file"
}

// trimPrefix removes the specified prefix from a string.
func trimPrefix(s, prefix string) string {
	if len(s) >= len(prefix) && s[:len(prefix)] == prefix {
		return s[len(prefix):]
	}
	return s
}
```
## ./internal/dce/filtered_data_utils.go
```
// internal/dce/filtered_data_utils.go

package dce

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
)

// buildRelevantFileHierarchy builds a file hierarchy for relevant files
// using standard filepath package instead of non-existent utils functions
func buildRelevantFileHierarchy(tasks []contextpkg.Task) string {
	var builder strings.Builder

	// Group files by directory
	dirs := make(map[string][]string)
	for _, task := range tasks {
		for _, file := range task.Files {
			// Use standard filepath functions instead of custom utils ones
			dir := filepath.Dir(file)
			filename := filepath.Base(file)
			dirs[dir] = append(dirs[dir], filename)
		}
	}

	// Format as a tree
	for dir, files := range dirs {
		builder.WriteString(fmt.Sprintf("%s/\n", dir))
		for _, file := range files {
			builder.WriteString(fmt.Sprintf("  â”œâ”€â”€ %s\n", file))
		}
		builder.WriteString("\n")
	}

	return builder.String()
}

// buildSimplifiedLinterResults creates a simplified linter results string
// This is a placeholder until actual linter integration is implemented
func buildSimplifiedLinterResults(tasks []contextpkg.Task) string {
	var builder strings.Builder

	// Count total files and functions to provide some basic metrics
	totalFiles := 0
	totalFunctions := 0

	for _, task := range tasks {
		totalFiles += len(task.Files)
		totalFunctions += len(task.Functions)
	}

	if totalFiles == 0 {
		builder.WriteString("No relevant files found for analysis.")
		return builder.String()
	}

	builder.WriteString(fmt.Sprintf("Analyzed %d files with %d functions.\n", totalFiles, totalFunctions))
	builder.WriteString("Note: Full linter integration is not yet implemented.\n\n")

	// Add some basic information about the tasks
	builder.WriteString("Task Summary:\n")
	for i, task := range tasks {
		builder.WriteString(fmt.Sprintf("%d. %s\n", i+1, task.Description))

		if len(task.Files) > 0 {
			builder.WriteString(fmt.Sprintf("   â€¢ Files: %d\n", len(task.Files)))
		}
		if len(task.Functions) > 0 {
			builder.WriteString(fmt.Sprintf("   â€¢ Functions: %d\n", len(task.Functions)))
		}
		if len(task.Notes) > 0 {
			builder.WriteString("   â€¢ Notes: Available\n")
		}
		builder.WriteString("\n")
	}

	return builder.String()
}
func GenerateFilteredData(tasks []contextpkg.Task) ([]FilteredData, []string, error) {
	var logs []string
	var filtered []FilteredData

	logs = append(logs, "Generating filtered data from tasks")

	// 1. Build file hierarchy for relevant files
	fileHierarchy := buildRelevantFileHierarchy(tasks)

	// 2. Get linter results (simplified version)
	linterResults, linterLogs := getLinterResults(tasks)
	logs = append(logs, linterLogs...)

	fd := FilteredData{
		FileHierarchy: fileHierarchy,
		LinterResults: linterResults,
	}
	filtered = append(filtered, fd)

	logs = append(logs, "Generated filtered data with linter integration")
	return filtered, logs, nil
}

// getLinterResults provides a simplified linter integration
func getLinterResults(tasks []contextpkg.Task) (string, []string) {
	var logs []string
	var builder strings.Builder

	totalFiles := 0
	for _, task := range tasks {
		totalFiles += len(task.Files)
	}

	if totalFiles == 0 {
		return "No files to analyze.", logs
	}

	builder.WriteString(fmt.Sprintf("Analyzed %d files across %d tasks:\n\n", totalFiles, len(tasks)))

	// For demonstration, let's assume we find some potential issues
	issuesFound := 0
	for _, task := range tasks {
		for _, file := range task.Files {
			// In a real implementation, this would run an actual linter
			if strings.HasSuffix(file, ".go") {
				// Simulate finding some issues in Go files
				if issuesFound == 0 {
					builder.WriteString("Potential issues detected:\n")
				}

				if strings.Contains(file, "handler") {
					builder.WriteString(fmt.Sprintf("- %s: Consider adding error handling\n", file))
					issuesFound++
				}
				if strings.Contains(file, "service") {
					builder.WriteString(fmt.Sprintf("- %s: Missing unit tests\n", file))
					issuesFound++
				}
			}
		}
	}

	if issuesFound == 0 {
		builder.WriteString("No immediate issues detected. Code looks good!\n")
	} else {
		builder.WriteString("\nRecommended next steps:\n")
		builder.WriteString("- Address the identified issues\n")
		builder.WriteString("- Consider writing additional tests\n")
		builder.WriteString("- Review documentation\n")
	}

	logs = append(logs, fmt.Sprintf("Found %d potential issues", issuesFound))
	return builder.String(), logs
}
```
## ./internal/utils/logutils.go
```
package utils

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/soyuz43/prbuddy-go/internal/contextpkg"
)

// LogLittleGuyContext writes the given data to a file named "littleguy-<conversationID>.txt"
// in a dedicated "logs" directory. A timestamp is prepended to each log entry.
func LogLittleGuyContext(conversationID, data string) error {
	logsDir := "logs"
	if err := os.MkdirAll(logsDir, 0755); err != nil {
		return fmt.Errorf("failed to create logs directory: %w", err)
	}

	filename := filepath.Join(logsDir, fmt.Sprintf("littleguy-%s.txt", conversationID))
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	line := fmt.Sprintf("[%s] %s\n", timestamp, data)

	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0640)
	if err != nil {
		return fmt.Errorf("failed to open log file: %w", err)
	}
	defer f.Close()

	if _, err := f.WriteString(line); err != nil {
		return fmt.Errorf("failed to write to log file: %w", err)
	}
	return nil
}

// SaveContextToFile marshals a slice of context messages (from contextpkg.Message) to JSON and writes
// the result to a timestamped file in the repository's .git/pr_buddy_db/context_logs directory.
func SaveContextToFile(conversationID string, messages []contextpkg.Message) error {
	repoPath, err := GetRepoPath()
	if err != nil {
		return fmt.Errorf("failed to get repository path: %w", err)
	}

	logDir := filepath.Join(repoPath, ".git", "pr_buddy_db", "context_logs")
	if err := os.MkdirAll(logDir, 0750); err != nil {
		return fmt.Errorf("failed to create context_logs directory: %w", err)
	}

	timestamp := time.Now().Format("20060102-150405")
	filename := fmt.Sprintf("conversation-%s-%s.json", conversationID, timestamp)
	filePath := filepath.Join(logDir, filename)

	jsonData, err := json.MarshalIndent(messages, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal context messages to JSON: %w", err)
	}

	if err := os.WriteFile(filePath, jsonData, 0640); err != nil {
		return fmt.Errorf("failed to write context to file: %w", err)
	}

	fmt.Printf("[Context Logger] Structured context successfully saved to %s\n", filePath)
	return nil
}

// SaveConcatenatedContextToFile concatenates a slice of context messages into a readable string and
// writes it to a timestamped text file in the repository's .git/pr_buddy_db/context_logs directory.
func SaveConcatenatedContextToFile(conversationID string, messages []contextpkg.Message) error {
	repoPath, err := GetRepoPath()
	if err != nil {
		return fmt.Errorf("failed to get repository path: %w", err)
	}

	logDir := filepath.Join(repoPath, ".git", "pr_buddy_db", "context_logs")
	if err := os.MkdirAll(logDir, 0750); err != nil {
		return fmt.Errorf("failed to create context_logs directory: %w", err)
	}

	timestamp := time.Now().Format("20060102-150405")
	filename := fmt.Sprintf("conversation-%s-%s.txt", conversationID, timestamp)
	filePath := filepath.Join(logDir, filename)

	capitalizer := cases.Title(language.English)
	var builder strings.Builder
	for _, msg := range messages {
		builder.WriteString(fmt.Sprintf("%s: %s\n", capitalizer.String(msg.Role), msg.Content))
	}
	concatenatedContext := builder.String()

	if err := os.WriteFile(filePath, []byte(concatenatedContext), 0640); err != nil {
		return fmt.Errorf("failed to write concatenated context to file: %w", err)
	}

	fmt.Printf("[Context Logger] Concatenated context successfully saved to %s\n", filePath)
	return nil
}
```
## ./internal/utils/colorutils.go
```
package utils

import "github.com/fatih/color"

var (
	Cyan    = color.New(color.FgCyan).SprintFunc()
	Green   = color.New(color.FgGreen).SprintFunc()
	Yellow  = color.New(color.FgYellow).SprintFunc()
	Red     = color.New(color.FgRed).SprintFunc()
	Magenta = color.New(color.FgMagenta).SprintFunc()
	Bold    = color.New(color.Bold).SprintFunc()
)
```
## ./internal/utils/gitutils.go
```
package utils

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// ExecGit executes a git command with the given arguments and returns the trimmed output.
func ExecGit(args ...string) (string, error) {
	cmd := exec.Command("git", args...)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("git %s failed: %w (stderr: %q)",
			strings.Join(args, " "),
			err,
			stderr.String())
	}

	return strings.TrimSpace(stdout.String()), nil
}

// GetRepoPath returns the top-level path of the current Git repository.
func GetRepoPath() (string, error) {
	return ExecGit("rev-parse", "--show-toplevel")
}

// ReadGitignore reads the .gitignore file at the given root directory and returns
// a slice of compiled regular expressions representing ignore patterns.
func ReadGitignore(rootDir string) ([]*regexp.Regexp, error) {
	gitignorePath := filepath.Join(rootDir, ".gitignore")

	file, err := os.Open(gitignorePath)
	if err != nil {
		// If .gitignore doesn't exist, return an empty slice.
		if os.IsNotExist(err) {
			return []*regexp.Regexp{}, nil
		}
		return nil, fmt.Errorf("failed to open .gitignore: %w", err)
	}
	defer file.Close()

	var patterns []*regexp.Regexp
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		// Skip empty lines or comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		// Convert the gitignore pattern to a regex:
		// 1) Escape special regex characters
		// 2) Convert "*" to ".*"
		// 3) Anchor the pattern to match entire path
		regexPattern := "^" + regexp.QuoteMeta(line) + "$"
		regexPattern = strings.ReplaceAll(regexPattern, "\\*", ".*")
		regex, err := regexp.Compile(regexPattern)
		if err == nil {
			patterns = append(patterns, regex)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading .gitignore: %w", err)
	}

	return patterns, nil
}

// IsIgnored returns true if the file path matches any of the given ignore patterns.
func IsIgnored(path string, patterns []*regexp.Regexp) bool {
	for _, regex := range patterns {
		if regex.MatchString(path) {
			return true
		}
	}
	return false
}

// GetCurrentBranch returns the current Git branch name.
func GetCurrentBranch() (string, error) {
	return ExecGit("rev-parse", "--abbrev-ref", "HEAD")
}

// GetLatestCommit returns the full SHA of the latest commit (HEAD).
func GetLatestCommit() (string, error) {
	return ExecGit("rev-parse", "HEAD")
}
```
## ./internal/utils/stringutils.go
```
package utils

import "strings"

// SplitLines splits a string into lines, removing any trailing newline.
func SplitLines(s string) []string {
	return strings.Split(strings.TrimSuffix(s, "\n"), "\n")
}

// JoinLines joins a slice of strings into a single string separated by newlines.
func JoinLines(lines []string) string {
	return strings.Join(lines, "\n")
}

// SanitizeBranchName replaces "/" with "_" and spaces with "-" in branch names.
func SanitizeBranchName(branch string) string {
	return strings.ReplaceAll(strings.ReplaceAll(branch, "/", "_"), " ", "-")
}

// StringSliceContains returns true if the slice contains the value.
func StringSliceContains(slice []string, val string) bool {
	for _, s := range slice {
		if s == val {
			return true
		}
	}
	return false
}
```
## ./internal/utils/diff.go
```
package utils

import (
	"fmt"
	"strings"
)

type DiffMode int

const (
	DiffSinceLastCommit DiffMode = iota
	DiffAllLocalChanges
)

// GetDiffs returns diffs based on the given mode.
// It leverages the unified ExecGit (from gitutils.go) for all Git operations.
func GetDiffs(mode DiffMode) (string, error) {
	switch mode {
	case DiffSinceLastCommit:
		return ExecGit("diff", "HEAD~1", "HEAD")
	case DiffAllLocalChanges:
		staged, err := ExecGit("diff", "--cached", "HEAD")
		if err != nil {
			return "", fmt.Errorf("error getting staged diff: %w", err)
		}
		unstaged, err := ExecGit("diff", "HEAD")
		if err != nil {
			return "", fmt.Errorf("error getting unstaged diff: %w", err)
		}
		untracked, err := ExecGit("ls-files", "--others", "--exclude-standard")
		if err != nil {
			return "", fmt.Errorf("error getting untracked files: %w", err)
		}

		var builder strings.Builder
		if staged != "" {
			builder.WriteString(fmt.Sprintf("--- Staged Changes ---\n%s\n\n", staged))
		}
		if unstaged != "" {
			builder.WriteString(fmt.Sprintf("--- Unstaged Changes ---\n%s\n\n", unstaged))
		}
		if untracked != "" {
			builder.WriteString(fmt.Sprintf("--- Untracked Files ---\n%s\n\n", untracked))
		}

		return builder.String(), nil

	default:
		return "", fmt.Errorf("unknown diff mode: %d", mode)
	}
}
```
## ./internal/utils/port_file.go
```
package utils

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"syscall"
)

const (
	appName      = "prbuddy-go"
	portFileName = "port"
	filePerm     = 0600 // rw-------
	dirPerm      = 0700 // rwx------
)

// EnsureAppCacheDir creates (if necessary) and verifies the application cache directory.
func EnsureAppCacheDir() error {
	cacheDir, err := getAppCacheDirPath()
	if err != nil {
		return err
	}

	if err := os.MkdirAll(cacheDir, dirPerm); err != nil {
		return fmt.Errorf("failed to create application directory: %w", err)
	}

	return verifyDirectoryPermissions(cacheDir)
}

func getAppCacheDirPath() (string, error) {
	cacheDir, err := os.UserCacheDir()
	if err != nil {
		return "", fmt.Errorf("failed to locate user cache directory: %w", err)
	}
	return filepath.Join(cacheDir, appName), nil
}

func verifyDirectoryPermissions(path string) error {
	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("failed to stat directory: %w", err)
	}

	if !info.IsDir() {
		return fmt.Errorf("cache path is not a directory: %s", path)
	}

	if info.Mode().Perm()&0077 != 0 {
		return fmt.Errorf("insecure permissions on cache directory: %#o", info.Mode().Perm())
	}

	return nil
}

// WritePortFile writes the given port number atomically to a port file.
func WritePortFile(port int) error {
	if port < 1 || port > 65535 {
		return fmt.Errorf("invalid port number: %d", port)
	}

	if err := EnsureAppCacheDir(); err != nil {
		return fmt.Errorf("cache directory validation failed: %w", err)
	}

	cacheDir, err := getAppCacheDirPath()
	if err != nil {
		return err
	}

	tmpFile, err := os.CreateTemp(cacheDir, "port-*.tmp")
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer cleanupTempFile(tmpFile)

	if err := performAtomicWrite(tmpFile, port); err != nil {
		return err
	}

	return finalizePortFile(tmpFile, cacheDir)
}

func performAtomicWrite(tmpFile *os.File, port int) error {
	if err := syscall.Flock(int(tmpFile.Fd()), syscall.LOCK_EX); err != nil {
		return fmt.Errorf("file lock failed: %w", err)
	}

	if _, err := fmt.Fprintf(tmpFile, "%d", port); err != nil {
		return fmt.Errorf("port write failed: %w", err)
	}

	if err := tmpFile.Sync(); err != nil {
		return fmt.Errorf("file sync failed: %w", err)
	}

	return nil
}

func finalizePortFile(tmpFile *os.File, cacheDir string) error {
	finalPath := filepath.Join(cacheDir, portFileName)
	if err := os.Rename(tmpFile.Name(), finalPath); err != nil {
		return fmt.Errorf("atomic rename failed: %w", err)
	}

	return os.Chmod(finalPath, filePerm)
}

func cleanupTempFile(tmpFile *os.File) {
	tmpFile.Close()
	os.Remove(tmpFile.Name())
}

// ReadPortFile reads and validates the port number from the port file.
func ReadPortFile() (int, error) {
	if err := EnsureAppCacheDir(); err != nil {
		return 0, fmt.Errorf("cache directory validation failed: %w", err)
	}

	cacheDir, err := getAppCacheDirPath()
	if err != nil {
		return 0, err
	}

	file, err := os.Open(filepath.Join(cacheDir, portFileName))
	if err != nil {
		return 0, fmt.Errorf("failed to open port file: %w", err)
	}
	defer file.Close()

	if err := syscall.Flock(int(file.Fd()), syscall.LOCK_SH); err != nil {
		return 0, fmt.Errorf("file lock failed: %w", err)
	}

	data, err := io.ReadAll(file)
	if err != nil {
		return 0, fmt.Errorf("read failed: %w", err)
	}

	return validatePortData(data)
}

func validatePortData(data []byte) (int, error) {
	portStr := string(bytes.TrimSpace(data))
	if portStr == "" {
		return 0, fmt.Errorf("empty port file")
	}

	port, err := strconv.Atoi(portStr)
	if err != nil {
		return 0, fmt.Errorf("invalid port format: %w", err)
	}

	if port < 1 || port > 65535 {
		return 0, fmt.Errorf("port %d out of valid range", port)
	}

	return port, nil
}

// DeletePortFile removes the port file.
func DeletePortFile() error {
	cacheDir, err := getAppCacheDirPath()
	if err != nil {
		return err
	}

	portPath := filepath.Join(cacheDir, portFileName)
	if err := os.Remove(portPath); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("delete failed: %w", err)
	}

	return nil
}
```
## ./internal/utils/extension_utils.go
```
package utils

import (
	"fmt"
	"os"
	"path/filepath"
)

// CheckExtensionInstalled verifies if the extension installation marker exists.
func CheckExtensionInstalled() (bool, error) {
	repoPath, err := GetRepoPath()
	if err != nil {
		return false, fmt.Errorf("failed to get repository path: %w", err)
	}
	indicatorPath := filepath.Join(repoPath, ".git", "prbuddy", ".extension-installed")
	if _, err := os.Stat(indicatorPath); err != nil {
		if os.IsNotExist(err) {
			return false, nil
		}
		return false, fmt.Errorf("error checking extension status: %w", err)
	}
	return true, nil
}

// CreateExtensionIndicator creates the extension installation marker.
func CreateExtensionIndicator() error {
	repoPath, err := GetRepoPath()
	if err != nil {
		return fmt.Errorf("failed to get repository path: %w", err)
	}
	prbuddyPath := filepath.Join(repoPath, ".git", "prbuddy")
	if err := os.MkdirAll(prbuddyPath, 0750); err != nil {
		return fmt.Errorf("failed to create prbuddy directory: %w", err)
	}
	indicatorPath := filepath.Join(prbuddyPath, ".extension-installed")
	if err := os.WriteFile(indicatorPath, []byte(""), 0640); err != nil {
		return fmt.Errorf("failed to create extension indicator: %w", err)
	}
	return nil
}

// RemoveExtensionIndicator removes the extension installation marker.
func RemoveExtensionIndicator() error {
	repoPath, err := GetRepoPath()
	if err != nil {
		return fmt.Errorf("failed to get repository path: %w", err)
	}
	indicatorPath := filepath.Join(repoPath, ".git", "prbuddy", ".extension-installed")
	if err := os.Remove(indicatorPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove extension indicator: %w", err)
	}
	return nil
}
```
## ./internal/utils/fileutils.go
```
package utils

import (
	"fmt"
	"os"
	"path/filepath"
	"syscall"
)

// ! WriteFile performs an atomic write to the given file path by writing to a temporary file
// ! with an exclusive lock, then renaming it into place.
func WriteFile(path string, data []byte) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Create a temporary file in the same directory.
	file, err := os.CreateTemp(dir, "tmp-")
	if err != nil {
		return fmt.Errorf("failed to create temp file: %w", err)
	}
	defer os.Remove(file.Name())

	if err := syscall.Flock(int(file.Fd()), syscall.LOCK_EX); err != nil {
		return fmt.Errorf("file lock failed: %w", err)
	}
	defer syscall.Flock(int(file.Fd()), syscall.LOCK_UN)

	if _, err := file.Write(data); err != nil {
		return fmt.Errorf("write failed: %w", err)
	}

	if err := os.Rename(file.Name(), path); err != nil {
		return fmt.Errorf("atomic rename failed: %w", err)
	}

	return nil
}

// ReadFile reads the file at the given path while holding a shared lock.
func ReadFile(path string) ([]byte, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	if err := syscall.Flock(int(file.Fd()), syscall.LOCK_SH); err != nil {
		return nil, fmt.Errorf("file lock failed: %w", err)
	}
	defer syscall.Flock(int(file.Fd()), syscall.LOCK_UN)

	return os.ReadFile(path)
}
```
## ./internal/utils/json_utils.go
```
package utils

import (
	"encoding/json"
	"fmt"
)

// MarshalJSON converts the given data to a pretty-printed JSON string.
func MarshalJSON(data interface{}) (string, error) {
	jsonBytes, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return "", fmt.Errorf("JSON marshaling failed: %w", err)
	}
	return string(jsonBytes), nil
}
```
## ./internal/hooks/remove_hook.go
```
// internal/hooks/remove_hook.go

package hooks

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/soyuz43/prbuddy-go/internal/utils"
)

// RemovePostCommitHook removes the post-commit Git hook
func RemovePostCommitHook() error {
	repoPath, err := utils.GetRepoPath()
	if err != nil {
		return err
	}

	postCommitPath := filepath.Join(repoPath, ".git", "hooks", "post-commit")

	if _, err := os.Stat(postCommitPath); os.IsNotExist(err) {
		fmt.Printf("[PRBuddy-Go] No post-commit hook found at %s\n", postCommitPath)
		return nil
	}

	err = os.Remove(postCommitPath)
	if err != nil {
		return fmt.Errorf("failed to remove post-commit hook: %w", err)
	}

	fmt.Printf("[PRBuddy-Go] post-commit hook removed from %s\n", postCommitPath)
	return nil
}
```
## ./internal/hooks/install_hook.go
```
package hooks

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/soyuz43/prbuddy-go/internal/utils"
)

func InstallPostCommitHook() error {
	repoPath, err := utils.GetRepoPath()
	if err != nil {
		return err
	}

	hooksDir := filepath.Join(repoPath, ".git", "hooks")

	// Ensure the hooks directory exists
	if _, err := os.Stat(hooksDir); os.IsNotExist(err) {
		err = os.MkdirAll(hooksDir, 0755)
		if err != nil {
			return fmt.Errorf("failed to create hooks directory: %w", err)
		}
	}

	// Define the hook content
	prBuddyHookContent := `echo "` + utils.Cyan("[PRBuddy-Go] Commit detected. Generating pull request...") + `"

# Run the PR generation command
prbuddy-go post-commit --non-interactive

if [ $? -eq 0 ]; then
  echo "` + utils.Green("[PRBuddy-Go] Pull request generated successfully.") + `"
else
  echo "` + utils.Red("[PRBuddy-Go] Failed to generate pull request.") + `"
fi`

	postCommitPath := filepath.Join(hooksDir, "post-commit")

	// Check if the post-commit hook already exists
	if _, err := os.Stat(postCommitPath); err == nil {
		// Read the existing hook content
		existingContent, err := os.ReadFile(postCommitPath)
		if err != nil {
			return fmt.Errorf("failed to read existing post-commit hook: %w", err)
		}

		// Check if the PRBuddy hook content is already present
		if strings.Contains(string(existingContent), "prbuddy-go post-commit") {
			fmt.Println(utils.Green("[PRBuddy-Go] post-commit hook already contains PRBuddy logic. Skipping reinstallation."))
			return nil
		}

		// Append PRBuddy hook content to the existing hook
		updatedContent := string(existingContent) + "\n\n# Added by PRBuddy-Go\n" + prBuddyHookContent
		err = os.WriteFile(postCommitPath, []byte(updatedContent), 0755)
		if err != nil {
			return fmt.Errorf("failed to append PRBuddy logic to existing post-commit hook: %w", err)
		}
		fmt.Println(utils.Green("[PRBuddy-Go] post-commit hook updated with PRBuddy logic."))
	} else {
		// If the hook doesn't exist, create a new one
		newHookContent := `
						#!/bin/bash
						# Added by PRBuddy-Go
						` + prBuddyHookContent

		err = os.WriteFile(postCommitPath, []byte(newHookContent), 0755)
		if err != nil {
			return fmt.Errorf("failed to write post-commit hook: %w", err)
		}
		fmt.Printf(utils.Cyan("[PRBuddy-Go] post-commit hook installed at %s\n"), postCommitPath)
	}

	return nil
}
```
